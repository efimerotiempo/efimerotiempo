{% extends 'base.html' %}

{% macro render_note_row(cell_tag, cols, notes, today) %}
    <tr class="notes-row">
        <{{ cell_tag }} class="resource-col"></{{ cell_tag }}>
        {% for c in cols %}
        {% if c.type == 'day' %}
        {% set d = c.dates[0] %}
        {% set ms = notes.get(d.isoformat()) %}
        <{{ cell_tag }} data-date="{{ d.isoformat() }}" class="note-cell{% if d == today %} today{% endif %}">
            {% if ms %}
                {% for m in ms %}
                <div class="note-label">{{ m }}</div>
                {% endfor %}
            {% endif %}
        </{{ cell_tag }}>
        {% else %}
        <{{ cell_tag }} colspan="2" class="weekend-cell{% if today in c.dates %} today{% endif %}"></{{ cell_tag }}>
        {% endif %}
        {% endfor %}
    </tr>
{% endmacro %}

{% block content %}
<div class="complete-container">
    <div class="complete-top">
    <div class="complete-notes">
        <h2>Notas</h2>
        <form method="post" action="{{ url_for('add_note') }}">
            <input type="hidden" name="next" value="{{ url_for('complete') }}">
            <table class="note-form">
                <tr>
                    <td>Descripción</td>
                    <td><input type="text" name="description" required></td>
                </tr>
                <tr>
                    <td>Fecha</td>
                    <td><input type="text" name="date" placeholder="dd-mm" required></td>
                </tr>
                <tr>
                    <td colspan="2" style="text-align:center;">
                        <button class="save-btn" type="submit">Añadir</button>
                    </td>
                </tr>
            </table>
        </form>
    </div>
    <div class="hours-btn-container">
        <button id="hours-btn" type="button">Editar jornada laboral</button>
        <button id="summary-pdf-btn" type="button">Resumen en PDF</button>
    </div>
    <div class="complete-conflicts">
        <h3>Conflictos</h3>
        <form method="post" action="{{ url_for('clear_conflicts') }}">
            <button type="submit">Borrar todos</button>
        </form>
        <form method="post" action="{{ url_for('show_conflicts') }}">
            <button type="submit">Mostrar todos</button>
        </form>
        <ul>
{% for c in conflicts %}
            <li class="{% if c.source == 'kanbanize' %}kanban-conflict{% endif %}"><a href="#" class="conflict-link" data-project="{{ c.project }}" {% if c.pid %}data-pid="{{ c.pid }}" data-offset="{{ c.offset }}"{% endif %}>{{ c.project }} - {{ c.client }}</a>: {{ c.message }}
                {% if c.changes %}
                <ul>
                {% for ch in c.changes %}
                    <li><a href="#" class="affected-link" data-project="{{ ch.name }}" data-pid="{{ ch.id }}" {% if ch.offset is not none %}data-offset="{{ ch.offset }}"{% endif %}>{{ ch.name }}</a> - {{ ch.client }}
                        {% if ch.met %}
                            <span class="ok">&#10004;</span>
                        {% else %}
                            <span class="late">&#10060;</span>
                        {% endif %}
                    </li>
                {% endfor %}
                </ul>
                {% endif %}
                <form method="post" action="{{ url_for('delete_conflict', key=c.key) }}" style="display:inline;">
                    <button type="submit">Borrar</button>
                </form>
            </li>
        {% endfor %}
        </ul>
    </div>
    </div> <!-- end complete-top -->
    <div class="complete-calendar">
        <h2>Calendario</h2>
        <div class="controls">
            <form id="filter-form" method="get">
                <input type="hidden" name="project_id" value="{{ project_id_filter }}">
                <label>Proyecto: <input type="text" name="project" value="{{ project_filter }}"></label>
                <label>Cliente: <input type="text" name="client" value="{{ client_filter }}"></label>
                <button type="submit">Filtrar</button>
            </form>
            <button id="today-btn" type="button">HOY</button>
            <button id="sort-due-btn" class="order-toggle" type="button">Fecha tope</button>
            <button id="sort-status-btn" class="order-toggle" type="button">Estado material</button>
        </div>
        <div class="calendar-flex">
        <div class="schedule-wrapper">
<table class="schedule">
    <thead>
    {% set day_names = ['Lun','Mar','Mié','Jue','Vie','Sáb','Dom'] %}
    <tr id="hours-row" class="hours-row" style="display:none;">
        <th class="resource-col">Horas</th>
        {% for c in cols %}
        {% if c.type == 'day' %}
        {% set d = c.dates[0] %}
        {% set h = hours.get(d.isoformat(), 8) %}
        <th><form class="hours-form" data-date="{{ d.isoformat() }}"><select>
            {% for n in range(1,10) %}
            <option value="{{n}}" {% if n==h %}selected{% endif %}>{{n}}h</option>
            {% endfor %}
        </select></form></th>
        {% else %}
        <th colspan="2" class="weekend-cell"></th>
        {% endif %}
        {% endfor %}
    </tr>
    {{ render_note_row('th', cols, notes, today) }}
    <tr class="day-row">
        <th class="resource-col">Recurso</th>
        {% for c in cols %}
        {% if c.type == 'day' %}
        {% set d = c.dates[0] %}
        <th class="{% if d == today %}today{% endif %}">{{ day_names[d.weekday()] }} {{ d.strftime('%d/%m') }}</th>
        {% else %}
        <th colspan="2" class="weekend{% if today in c.dates %} today{% endif %}"></th>
        {% endif %}
        {% endfor %}
    </tr>
    </thead>
    <tbody>
{% for worker, days_data in schedule.items() %}
    <tr data-worker="{{ worker }}">
        <td class="resource-col">
            <div class="worker-label">{{ worker }}</div>
            <textarea class="worker-note" data-worker="{{ worker }}">{{ worker_notes.get(worker, {}).get('text','') }}</textarea>
            {% set wn = worker_notes.get(worker) %}
            <div class="worker-note-time">{% if wn and wn.edited %}{{ wn.edited }}{% endif %}</div>
        </td>
        {% for c in cols %}
        {% if c.type == 'day' %}
        {% set d = c.dates[0] %}
        {% set tasks = days_data.get(d.isoformat(), []) %}
        {% set total = tasks|sum(attribute='hours') %}
        {% set worker_overrides = worker_day_hours.get(worker, {}) %}
        {% set base_limit = worker_limits.get(worker) %}
        {% set override = worker_overrides.get(d.isoformat()) %}
        {% if override is none %}
        {% set limit = hours.get(d.isoformat(), 8) %}
        {% else %}
        {% set limit = override %}
        {% endif %}
        {% set no_border = (tasks | selectattr('phase','equalto','vacaciones') | list | length > 0) or (tasks | selectattr('phase','equalto','mecanizar') | list | length > 0) or (tasks | selectattr('phase','equalto','tratamiento') | list | length > 0) or (worker in ['Mecanizar', 'Tratamiento']) %}
        <td data-date="{{ d.isoformat() }}" class="{% if total < limit and not no_border %}incomplete {% endif %}{% if override is not none and (base_limit is none or override != base_limit) %}hour-override {% endif %}{% if notes.get(d.isoformat()) %}note-day {% endif %}{% if d == today %}today {% endif %}{% if no_border %}vacation-day{% endif %}">
            {% for t in tasks %}
            {% set matches_filter = t.get('filter_match', True) %}
            {% if t.phase == 'vacaciones' %}
            <div class="task vacation{% if filter_active and not matches_filter %} filter-muted{% endif %}" data-worker="{{ worker }}" data-day="{{ d.isoformat() }}" data-filter-match="{{ 'true' if matches_filter else 'false' }}">VACACIONES<br><span class="vac-delete" style="display:none;">X</span></div>
            {% else %}
            {% set project_info = project_data.get(t.pid|string) %}
            {% if project_info is none %}
            {% set project_info = project_data.get(t.pid) %}
            {% endif %}
            {% set material_missing = project_info and project_info.material_status == 'missing' %}
            <div class="task{% if t.frozen %} frozen{% endif %}{% if t.archived_shadow %} archived-shadow{% endif %}{% if filter_active and not matches_filter %} filter-muted{% endif %}" draggable="{{ 'false' if t.frozen or t.archived_shadow else 'true' }}" style="border-color: {{ t.color }};{% if t.frozen_background %} --frozen-background: {{ t.frozen_background }};{% endif %}" data-project="{{ t.project }}" data-client="{{ t.client }}" data-due="{{ t.due_date }}" data-start="{{ t.start_date }}" data-day="{{ d.isoformat() }}" data-pid="{{ t.pid }}" data-phase="{{ t.phase }}"{% if t.part is not none %} data-part="{{ t.part }}"{% endif %} data-hours="{{ t.hours }}" data-filter-match="{{ 'true' if matches_filter else 'false' }}" data-archived="{{ 'true' if t.archived_shadow else 'false' }}">
                <span class="task-main">
                {% set phase_status = t.get('phase_deadline_status') %}
                {% if phase_status == 'late' %}
                    <span class="phase-deadline-indicator phase-deadline-late">&#10060;</span>
                {% elif phase_status == 'met' %}
                    <span class="phase-deadline-indicator phase-deadline-met">&#10004;</span>
                {% elif t.due_status == 'after' %}
                    <span class="due-after">&#10060;</span>
                {% elif t.due_status == 'before' %}
                    <span class="due-before">&#10060;</span>
                {% elif t.due_status == 'met' %}
                    <span class="due-ok">&#10004;</span>
                {% endif %}
                {% set key = t.pid ~ '|' ~ t.phase ~ '|' ~ d.isoformat() %}
                {% if key in split_points %}<span class="split-dot">&#9679;</span> {% endif %}
                    <span class="task-project{% if material_missing %} task-project-missing{% endif %}">{{ t.project }}</span>{% if t.blocked %}<span class="blocked-sign">&#128683;</span>{% endif %} - {{ t.client|truncate(15, True) }} - {{ t.phase }}{% if t.part is not none %} ({{ t.part|int + 1 }}){% endif %}
                </span>
                {% if t.hours %}
                <span class="task-hours">{% if t.auto %}<span class="auto-hour">{{ t.hours }}h</span>{% else %}{{ t.hours }}h{% endif %}</span>
                {% endif %}
            </div>
            {% endif %}
            {% endfor %}
        </td>
        {% else %}
        <td colspan="2" class="weekend-cell{% if today in c.dates %} today{% endif %}"></td>
        {% endif %}
        {% endfor %}
    </tr>
{% endfor %}
    </tbody>
    <tfoot>
    <tr class="day-row">
        <th class="resource-col">Recurso</th>
        {% for c in cols %}
        {% if c.type == 'day' %}
        {% set d = c.dates[0] %}
        <th class="{% if d == today %}today{% endif %}">{{ day_names[d.weekday()] }} {{ d.strftime('%d/%m') }}</th>
        {% else %}
        <th colspan="2" class="weekend{% if today in c.dates %} today{% endif %}"></th>
        {% endif %}
        {% endfor %}
    </tr>
    </tfoot>
        </table>
        </div>
        <div class="unplanned-panel" id="unplanned-panel">
            <div id="unplanned-resizer" class="unplanned-resizer"></div>
            <h3>Fases sin planificar</h3>
            <div class="manual-group">
                <div class="manual-header">Arrastrar aquí</div>
                <div id="manual-dropzone" class="manual-dropzone" data-worker="Sin planificar">
                    <div class="manual-placeholder"{% if manual_bucket %} style="display:none;"{% endif %}>Suelta aquí las fases que quieras guardar temporalmente.</div>
                {% for item in manual_bucket %}
                    {% set matches_filter = item.filter_match %}
                    {% set status = item.material_status %}
                    {% set missing = status == 'missing' %}
                    {% set key = item.pid|string ~ '|' ~ item.phase ~ '|' ~ (item.day) %}
                    <div class="task manual-task{% if item.frozen %} frozen{% endif %}{% if filter_active and not matches_filter %} filter-muted{% endif %}" draggable="true" style="border-color: {{ item.color }};{% if item.frozen_background %} --frozen-background: {{ item.frozen_background }};{% endif %}" data-project="{{ item.project }}" data-client="{{ item.client }}" data-due="{{ item.due_date or '' }}" data-start="{{ item.start_date or '' }}" data-day="{{ item.day or '' }}" data-pid="{{ item.pid }}" data-phase="{{ item.phase }}"{% if item.part is not none %} data-part="{{ item.part }}"{% endif %} data-filter-match="{{ 'true' if matches_filter else 'false' }}">
                        <span class="task-main">
                        {% set phase_status = item.phase_deadline_status %}
                        {% if phase_status == 'late' %}
                            <span class="phase-deadline-indicator phase-deadline-late">&#10060;</span>
                        {% elif phase_status == 'met' %}
                            <span class="phase-deadline-indicator phase-deadline-met">&#10004;</span>
                        {% elif item.due_status == 'after' %}
                            <span class="due-after">&#10060;</span>
                        {% elif item.due_status == 'before' %}
                            <span class="due-before">&#10060;</span>
                        {% elif item.due_status == 'met' %}
                            <span class="due-ok">&#10004;</span>
                        {% endif %}
                        {% if key in split_points %}<span class="split-dot">&#9679;</span> {% endif %}
                        <span class="material-status-flag {{ item.material_css }}">{{ item.material_label }}</span>
                        <span class="task-project{% if missing %} task-project-missing{% endif %}">{{ item.project }}</span>{% if item.blocked %}<span class="blocked-sign">&#128683;</span>{% endif %} - {{ item.client|truncate(15, True) }} - {{ item.phase }}{% if item.part is not none %} ({{ item.part|int + 1 }}){% endif %}
                        </span>
                        {% if item.hours %}
                        <span class="task-hours">{% if item.auto and item.phase not in ['mecanizar', 'tratamiento'] %}<span class="auto-hour">{{ item.hours }}h</span>{% else %}{{ item.hours }}h{% endif %}</span>
                        {% endif %}
                    </div>
                {% endfor %}
                </div>
            </div>
            <div class="unplanned-list" data-worker="Sin planificar" data-mode="status">
            {% for section in unplanned_groups %}
            <div class="unplanned-status-group" data-status="{{ section.status }}">
                <div class="unplanned-status-header"><span class="material-status-flag {{ section.css_class }}">{{ section.label }}</span></div>
                {% for g in section.projects %}
            {% set folder_match = g.get('filter_match', True) %}
            {% set folder_missing = section.status == 'missing' %}
            <div class="unplanned-folder{% if filter_active and not folder_match %} filter-muted{% endif %}" data-pid="{{ g.pid }}" data-status="{{ section.status }}" data-due="{{ g.due_date or '' }}" data-filter-match="{{ 'true' if folder_match else 'false' }}">
                <div class="folder-header"><button type="button" class="folder-toggle">&#43;</button> <span class="task-project{% if folder_missing %} task-project-missing{% endif %}">{{ g.project }}</span> - {{ g.client }}{% if g.due_date %} - <span class="folder-due">{{ g.due_date }}</span>{% endif %}</div>
                <div class="folder-content" style="display:none;">
                {% for t in g.tasks %}
                {% set matches_filter = t.get('filter_match', True) %}
                <div class="task{% if t.frozen %} frozen{% endif %}{% if filter_active and not matches_filter %} filter-muted{% endif %}" draggable="true" style="border-color: {{ t.color }};{% if t.frozen_background %} --frozen-background: {{ t.frozen_background }};{% endif %}" data-project="{{ t.project }}" data-client="{{ t.client }}" data-due="{{ t.due_date }}" data-start="{{ t.start_date }}" data-day="{{ t.day }}" data-pid="{{ t.pid }}" data-phase="{{ t.phase }}"{% if t.part is not none %} data-part="{{ t.part }}"{% endif %} data-filter-match="{{ 'true' if matches_filter else 'false' }}">
                    <span class="task-main">
                    {% set phase_status = t.get('phase_deadline_status') %}
                    {% if phase_status == 'late' %}
                        <span class="phase-deadline-indicator phase-deadline-late">&#10060;</span>
                    {% elif phase_status == 'met' %}
                        <span class="phase-deadline-indicator phase-deadline-met">&#10004;</span>
                    {% elif t.due_status == 'after' %}
                        <span class="due-after">&#10060;</span>
                    {% elif t.due_status == 'before' %}
                        <span class="due-before">&#10060;</span>
                    {% elif t.due_status == 'met' %}
                        <span class="due-ok">&#10004;</span>
                    {% endif %}
                    {% set key = t.pid ~ '|' ~ t.phase ~ '|' ~ t.day %}
                    {% if key in split_points %}<span class="split-dot">&#9679;</span> {% endif %}
                    <span class="task-project{% if folder_missing %} task-project-missing{% endif %}">{{ t.project }}</span>{% if t.blocked %}<span class="blocked-sign">&#128683;</span>{% endif %} - {{ t.client|truncate(15, True) }} - {{ t.phase }}{% if t.part is not none %} ({{ t.part|int + 1 }}){% endif %}
                    </span>
                    {% if t.hours %}
                    <span class="task-hours">{% if t.auto %}<span class="auto-hour">{{ t.hours }}h</span>{% else %}{{ t.hours }}h{% endif %}</span>
                    {% endif %}
                </div>
                {% endfor %}
                </div>
            </div>
                {% endfor %}
            </div>
            {% endfor %}
            </div>
            <div class="unplanned-list" data-worker="Sin planificar" data-mode="due" style="display:none;">
            {% for g in unplanned_due %}
            {% set folder_match = g.get('filter_match', True) %}
            {% set status = g.get('material_status', 'complete') %}
            {% set status_label = material_status_labels.get(status, status|capitalize) %}
            {% set folder_missing = status == 'missing' %}
            <div class="unplanned-folder{% if filter_active and not folder_match %} filter-muted{% endif %}" data-pid="{{ g.pid }}" data-status="{{ status }}" data-due="{{ g.due_date or '' }}" data-filter-match="{{ 'true' if folder_match else 'false' }}">
                <div class="folder-header"><button type="button" class="folder-toggle">&#43;</button> <span class="material-status-flag material-status-{{ status }}">{{ status_label }}</span> <span class="task-project{% if folder_missing %} task-project-missing{% endif %}">{{ g.project }}</span> - {{ g.client }}{% if g.due_date %} - <span class="folder-due">{{ g.due_date }}</span>{% endif %}</div>
                <div class="folder-content" style="display:none;">
                {% for t in g.tasks %}
                {% set matches_filter = t.get('filter_match', True) %}
                <div class="task{% if t.frozen %} frozen{% endif %}{% if filter_active and not matches_filter %} filter-muted{% endif %}" draggable="true" style="border-color: {{ t.color }};{% if t.frozen_background %} --frozen-background: {{ t.frozen_background }};{% endif %}" data-project="{{ t.project }}" data-client="{{ t.client }}" data-due="{{ t.due_date }}" data-start="{{ t.start_date }}" data-day="{{ t.day }}" data-pid="{{ t.pid }}" data-phase="{{ t.phase }}"{% if t.part is not none %} data-part="{{ t.part }}"{% endif %} data-filter-match="{{ 'true' if matches_filter else 'false' }}">
                    <span class="task-main">
                    {% set phase_status = t.get('phase_deadline_status') %}
                    {% if phase_status == 'late' %}
                        <span class="phase-deadline-indicator phase-deadline-late">&#10060;</span>
                    {% elif phase_status == 'met' %}
                        <span class="phase-deadline-indicator phase-deadline-met">&#10004;</span>
                    {% elif t.due_status == 'after' %}
                        <span class="due-after">&#10060;</span>
                    {% elif t.due_status == 'before' %}
                        <span class="due-before">&#10060;</span>
                    {% elif t.due_status == 'met' %}
                        <span class="due-ok">&#10004;</span>
                    {% endif %}
                    {% set key = t.pid ~ '|' ~ t.phase ~ '|' ~ t.day %}
                    {% if key in split_points %}<span class="split-dot">&#9679;</span> {% endif %}
                    <span class="task-project{% if folder_missing %} task-project-missing{% endif %}">{{ t.project }}</span>{% if t.blocked %}<span class="blocked-sign">&#128683;</span>{% endif %} - {{ t.client|truncate(15, True) }} - {{ t.phase }}{% if t.part is not none %} ({{ t.part|int + 1 }}){% endif %}
                    </span>
                    {% if t.hours %}
                    <span class="task-hours">{% if t.auto %}<span class="auto-hour">{{ t.hours }}h</span>{% else %}{{ t.hours }}h{% endif %}</span>
                    {% endif %}
                </div>
                {% endfor %}
                </div>
            </div>
            {% endfor %}
            </div>
        </div>
        </div>
        <div id="info-popup" class="info-popup"></div>
<div id="conflict-modal" class="conflict-modal"><div class="conflict-content"><div id="conflict-text"></div><button id="conflict-close">Cerrar</button></div></div>
<div id="split-modal" class="conflict-modal">
  <div class="conflict-content">
    <form id="split-form">
      <div id="split-total-hours" class="split-total-hours"></div>
      <div id="split-parts-container" class="split-parts-container"></div>
      <button type="button" id="split-add-part" class="split-add-part" title="Añadir parte">+</button>
      <div class="split-actions">
        <button type="submit">Aceptar</button>
        <button type="button" id="split-cancel">Cancelar</button>
      </div>
    </form>
  </div>
</div>
<div id="block-modal" class="conflict-modal"><div class="conflict-content"><div id="block-text"></div><button id="block-unfreeze">Descongelar</button> <button id="block-skip">No descongelar</button> <button id="block-cancel">Cancelar</button></div></div>
<div id="history-modal" class="history-modal">
    <div class="history-content">
        <button type="button" class="history-close" aria-label="Cerrar">&#10005;</button>
        <h3 id="history-title">Historial</h3>
        <div id="history-list" class="history-list"></div>
    </div>
</div>
<div id="day-menu-modal" class="day-menu-modal" aria-hidden="true">
  <div class="day-menu-content">
    <button type="button" class="day-menu-close" aria-label="Cerrar">&#10005;</button>
    <div id="day-menu-title" class="day-menu-title"></div>
    <button type="button" id="day-menu-vacation" class="day-menu-action">Asignar vacaciones a este día</button>
    <div class="day-menu-hours">
      <select id="day-menu-hour-select" class="day-menu-select">
        {% for n in range(1, 11) %}
        <option value="{{ n }}">{{ n }}h</option>
        {% endfor %}
      </select>
      <button type="button" id="day-menu-hours-btn" class="day-menu-action">Cambiar jornada de este día</button>
    </div>
  </div>
</div>
    </div>
    <div class="complete-projects">
        <h2>Proyectos <button id="projects-toggle" type="button">&#8722;</button></h2>
        <form method="get" class="controls">
            <label>Proyecto: <input type="text" name="project" value="{{ project_filter }}"></label>
            <label>Cliente: <input type="text" name="client" value="{{ client_filter }}"></label>
            <label>Ordenar:
                <select name="sort">
                    <option value="created" {% if sort_option == 'created' %}selected{% endif %}>Creación</option>
                    <option value="name" {% if sort_option == 'name' %}selected{% endif %}>Nombre</option>
                </select>
            </label>
            <button type="submit">Filtrar</button>
        </form>
        <table class="projects-table">
            <thead>
            <tr>
                <th>Nombre</th>
                <th>Cliente</th>
                <th>Fecha límite</th>
                <th>Estado material</th>
                {% for ph in phases if ph not in ['dibujo', 'pedidos'] %}
                    <th>{{ ph }}</th>
                {% endfor %}
                <th>Actualizar</th>
                <th>X</th>
                <th>Imagen</th>
            </tr>
            </thead>
            <tbody>
            {% for p in projects %}
            <tr data-pid="{{ p.id }}" class="{% if p.frozen_tasks %}frozen{% endif %}">
                <td data-sort="{{ p.name|default('', true)|lower }}">{{ p.name }}</td>
                <td data-sort="{{ p.client|default('', true)|lower }}">{{ p.client }}</td>
                <td data-sort="{{ p.due_date or '' }}" data-sort-type="date">{{ p.due_date }}</td>
                {% set pid_key = p.id|string if p.id is not none else p.id %}
                {% set info = project_data.get(pid_key) %}
                {% set status = p.material_status if p.material_status is defined and p.material_status else (info.material_status if info else 'complete') %}
                {% set status_label = material_status_labels.get(status, status|capitalize) %}
                <td data-sort="{{ status_label|lower }}">
                    <span class="material-status-flag material-status-{{ status }}">{{ status_label }}</span>
                </td>
                {% for ph in phases if ph not in ['dibujo', 'pedidos'] %}
                    {% set val = p.phases.get(ph, 0) %}
                    {% if val is sequence %}
                        {% set total = val|map('int')|sum %}
                    {% else %}
                        {% set total = val|int %}
                    {% endif %}
                    <td data-sort="{{ total }}" data-sort-type="number">
                    {{ total }}h<br>
                        {% set assigned = p.assigned.get(ph) if p.assigned and p.assigned.get(ph) else 'Sin planificar' %}
                        <span>{{ assigned }}</span>
                        <form class="phase-hours-form" method="post" action="{{ url_for('update_phase_hours') }}">
                            <input type="hidden" name="pid" value="{{ p.id }}">
                            <input type="hidden" name="phase" value="{{ ph }}">
                            <input type="hidden" name="next" value="{{ url_for('complete') }}">
                            <input type="number" name="hours" value="{{ total }}" min="1">
                        </form>
                        <span>{{ start_map.get(p.id, {}).get(ph, '') }}</span>
                    </td>
                {% endfor %}
                <td data-sort="0"><button class="row-update-btn">ACTUALIZAR</button></td>
                <td data-sort="0">
                    <form method="post" action="{{ url_for('delete_project', pid=p.id, next=url_for('complete')) }}" class="delete-form">
                        <button class="delete-btn" type="submit">&#10060;</button>
                    </form>
                </td>
                <td data-sort="{{ 1 if p.image else 0 }}" data-sort-type="number">
                    {% if p.image %}
                        {{ p.image.rsplit('/', 1)[-1] }}
                    {% else %}
                        &mdash;
                    {% endif %}
                    <form class="image-form" method="post" enctype="multipart/form-data" action="{{ url_for('update_image', pid=p.id) }}">
                        <input type="hidden" name="next" value="{{ url_for('complete') }}">
                        <input type="file" name="image" accept="image/*">
                    </form>
                </td>
            </tr>
            {% endfor %}
            </tbody>
        </table>
    </div>
</div>
<script src="{{ url_for('static', filename='vendor/html2canvas.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/jspdf.umd.min.js') }}"></script>
<script>
  window.addEventListener('DOMContentLoaded', () => {
  const PROJECT_DATA = {{ project_data|tojson }};
  const PHASES = {{ phases|tojson }};
  const STATIC_URL = "{{ url_for('static', filename='') }}";
  const MOVE_URL = "{{ url_for('move_phase') }}";
  const DELETE_URL = "{{ url_for('delete_phase') }}";
  const START_URL = "{{ url_for('update_phase_start') }}";
  const PROJ_START_URL = "{{ url_for('update_start_date') }}";
  const SPLIT_URL = "{{ url_for('split_phase_route') }}";
  const UNSPLIT_URL = "{{ url_for('unsplit_phase') }}";

  function initProjectTableSorting(root = document) {
    const collator = new Intl.Collator('es', { sensitivity: 'base', numeric: true });
    root.querySelectorAll('.projects-table').forEach((table) => {
      const tbody = table.tBodies[0];
      if (!tbody) return;
      const headers = table.querySelectorAll('thead th');
      headers.forEach((th, index) => {
        th.classList.add('sortable');
        th.addEventListener('click', () => {
          const order = th.dataset.sortOrder === 'asc' ? 'desc' : 'asc';
          headers.forEach((other) => {
            if (other !== th) {
              other.dataset.sortOrder = '';
              other.classList.remove('sorted-asc', 'sorted-desc');
            }
          });
          th.dataset.sortOrder = order;
          th.classList.toggle('sorted-asc', order === 'asc');
          th.classList.toggle('sorted-desc', order === 'desc');
          const rows = Array.from(tbody.querySelectorAll('tr'));
          const parseCellValue = (cell) => {
            if (!cell) {
              return { blank: true, value: '', type: 'text' };
            }
            const raw = cell.dataset.sort !== undefined ? cell.dataset.sort : cell.textContent.trim();
            const type = cell.dataset.sortType || 'text';
            const rawString = raw === undefined || raw === null ? '' : `${raw}`;
            const isBlank = rawString.trim() === '';
            if (type === 'number') {
              const num = Number(rawString);
              return { blank: isBlank, value: Number.isNaN(num) ? 0 : num, type };
            }
            if (type === 'date') {
              if (isBlank) {
                return { blank: true, value: 0, type };
              }
              let time = Number.NaN;
              if (/^\d{4}-\d{2}-\d{2}$/.test(rawString)) {
                time = Date.parse(rawString);
              } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(rawString)) {
                const [day, month, year] = rawString.split('/').map(Number);
                if (!Number.isNaN(day) && !Number.isNaN(month) && !Number.isNaN(year)) {
                  time = Date.UTC(year, month - 1, day);
                }
              } else {
                time = Date.parse(rawString);
              }
              if (Number.isNaN(time)) {
                return { blank: true, value: 0, type };
              }
              return { blank: false, value: time, type };
            }
            return { blank: isBlank, value: rawString.toLowerCase(), type: 'text' };
          };
          rows.sort((a, b) => {
            const aCell = a.children[index];
            const bCell = b.children[index];
            const aVal = parseCellValue(aCell);
            const bVal = parseCellValue(bCell);
            if (aVal.blank && bVal.blank) return 0;
            if (aVal.blank !== bVal.blank) {
              return aVal.blank ? 1 : -1;
            }
            let comparison = 0;
            if (aVal.type === 'number' && bVal.type === 'number') {
              comparison = aVal.value - bVal.value;
            } else if (aVal.type === 'date' && bVal.type === 'date') {
              comparison = aVal.value - bVal.value;
            } else {
              comparison = collator.compare(aVal.value, bVal.value);
            }
            if (comparison === 0) return 0;
            return order === 'asc' ? (comparison < 0 ? -1 : 1) : (comparison < 0 ? 1 : -1);
          });
          rows.forEach((row) => tbody.appendChild(row));
        });
      });
    });
  }

  initProjectTableSorting();
  const REMOVE_ARCHIVED_URL = "{{ url_for('remove_archived_phase') }}";
  const HOURS_URL = "{{ url_for('update_hours') }}";
  const PHASE_HOURS_URL = "{{ url_for('update_phase_hours') }}";
  const ROW_URL = "{{ url_for('update_project_row') }}";
  const WORKER_NOTE_URL = "{{ url_for('update_worker_note') }}";
  const OBS_URL_TEMPLATE = "{{ url_for('update_observations', pid='__PID__') }}";
  const MANUAL_REORDER_URL = "{{ url_for('manual_bucket_reorder_route') }}";
  const CALENDAR_PEDIDOS_URL = "{{ url_for('calendar_pedidos') }}";
  const HISTORY_URL = "{{ url_for('phase_history') }}";
  const ASSIGN_VACATION_DAY_URL = "{{ url_for('assign_vacation_day') }}";
  const UPDATE_WORKER_DAY_HOURS_URL = "{{ url_for('update_worker_day_hours') }}";
  const WORKER_DAY_HOURS = {{ worker_day_hours|tojson }};
  const DAILY_HOURS = {{ hours|tojson }};
  const START_DATA = {{ start_map|tojson }};
  const LAST_KEY = 'lastMoved';
  const SCROLL_KEY2 = 'scrollDate';
  const splitModal = document.getElementById('split-modal');
  const splitForm = document.getElementById('split-form');
  const splitPartsContainer = document.getElementById('split-parts-container');
  const splitAddPartButton = document.getElementById('split-add-part');
  const splitTotalDisplay = document.getElementById('split-total-hours');
  let splitRemainderInput = null;
  const blockModal = document.getElementById('block-modal');
  const blockText = document.getElementById('block-text');
  const blockUnfreeze = document.getElementById('block-unfreeze');
  const blockSkip = document.getElementById('block-skip');
  const blockCancel = document.getElementById('block-cancel');
  const historyModal = document.getElementById('history-modal');
  const historyList = document.getElementById('history-list');
  const historyClose = historyModal ? historyModal.querySelector('.history-close') : null;
  const historyTitle = document.getElementById('history-title');
  let detachHistoryViewport = null;
  let historyPositionFrame = null;

  function centerHistoryModalNow() {
    if (!historyModal || !historyModal.classList.contains('open')) return;
    const content = historyModal.querySelector('.history-content');
    if (!content) return;
    const viewport = window.visualViewport || null;
    let viewportWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0;
    let viewportHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0;
    let offsetLeft = 0;
    let offsetTop = 0;
    if (viewport) {
      viewportWidth = viewport.width;
      viewportHeight = viewport.height;
      offsetLeft = viewport.offsetLeft || viewport.pageLeft || viewport.left || 0;
      offsetTop = viewport.offsetTop || viewport.pageTop || viewport.top || 0;
    }
    const contentWidth = content.offsetWidth;
    const contentHeight = content.offsetHeight;
    const safePadding = 16;
    const targetLeft = offsetLeft + Math.max((viewportWidth - contentWidth) / 2, safePadding);
    const targetTop = offsetTop + Math.max((viewportHeight - contentHeight) / 2, safePadding);
    content.style.position = 'fixed';
    content.style.left = `${Math.round(targetLeft)}px`;
    content.style.top = `${Math.round(targetTop)}px`;
  }

  function scheduleHistoryModalCenter() {
    if (!historyModal || !historyModal.classList.contains('open')) return;
    if (historyPositionFrame !== null) return;
    historyPositionFrame = requestAnimationFrame(() => {
      historyPositionFrame = null;
      centerHistoryModalNow();
    });
  }

  function bindHistoryViewportTracking() {
    if (!historyModal || detachHistoryViewport) return;
    const viewport = window.visualViewport || null;
    const handler = () => scheduleHistoryModalCenter();
    window.addEventListener('resize', handler);
    window.addEventListener('scroll', handler, { passive: true });
    if (viewport) {
      viewport.addEventListener('resize', handler);
      viewport.addEventListener('scroll', handler);
    }
    detachHistoryViewport = () => {
      window.removeEventListener('resize', handler);
      window.removeEventListener('scroll', handler);
      if (viewport) {
        viewport.removeEventListener('resize', handler);
        viewport.removeEventListener('scroll', handler);
      }
      detachHistoryViewport = null;
    };
  }

  const dayMenuModal = document.getElementById('day-menu-modal');
  const dayMenuClose = dayMenuModal ? dayMenuModal.querySelector('.day-menu-close') : null;
  const dayMenuTitle = document.getElementById('day-menu-title');
  const dayMenuVacationBtn = document.getElementById('day-menu-vacation');
  const dayMenuHoursBtn = document.getElementById('day-menu-hours-btn');
  const dayMenuHourSelect = document.getElementById('day-menu-hour-select');
  let dayMenuWorker = null;
  let dayMenuDate = null;
  const dayMenuFormatter = typeof Intl !== 'undefined'
    ? new Intl.DateTimeFormat('es-ES', {
        timeZone: window.EFIMERO_TZ || 'Europe/Madrid',
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
      })
    : null;
  let pendingBlock = null;
  const SPLIT_WORKDAY_HOURS = 8;
  const SPLIT_ORDINAL_WORDS = ['primera', 'segunda', 'tercera', 'cuarta', 'quinta', 'sexta', 'séptima', 'octava', 'novena', 'décima'];

  const NO_BORDER_WORKERS = new Set(['Mecanizar', 'Tratamiento']);
  const NO_BORDER_PHASES = new Set(['vacaciones', 'mecanizar', 'tratamiento']);

  function getWorkerDayLimit(worker, dateText) {
    if (WORKER_DAY_HOURS && WORKER_DAY_HOURS[worker] && WORKER_DAY_HOURS[worker][dateText] !== undefined) {
      const parsed = Number(WORKER_DAY_HOURS[worker][dateText]);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    }
    if (DAILY_HOURS && DAILY_HOURS[dateText] !== undefined) {
      const parsed = Number(DAILY_HOURS[dateText]);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    }
    return 8;
  }

  function findWorkerRow(worker) {
    if (!worker) return null;
    return Array.from(document.querySelectorAll('tr[data-worker]')).find(row => row.dataset.worker === worker) || null;
  }

  function findWorkerDayCell(worker, dateText) {
    if (!worker || !dateText) return null;
    const row = findWorkerRow(worker);
    if (!row) return null;
    return Array.from(row.querySelectorAll('td[data-date]')).find(td => td.dataset.date === dateText) || null;
  }

  function recomputeWorkerDayCell(worker, dateText) {
    const cell = findWorkerDayCell(worker, dateText);
    if (!cell) return;
    const tasks = Array.from(cell.querySelectorAll('.task'));
    let total = 0;
    let hasNoBorderPhase = NO_BORDER_WORKERS.has(worker);
    tasks.forEach(task => {
      const phase = (task.dataset.phase || '').toLowerCase();
      if (NO_BORDER_PHASES.has(phase)) {
        hasNoBorderPhase = true;
      }
      const hoursVal = Number(task.dataset.hours);
      if (Number.isFinite(hoursVal)) {
        total += hoursVal;
      }
    });
    const limit = getWorkerDayLimit(worker, dateText);
    if (hasNoBorderPhase) {
      cell.classList.add('vacation-day');
      cell.classList.remove('incomplete');
      return;
    }
    cell.classList.remove('vacation-day');
    if (total < limit) {
      cell.classList.add('incomplete');
    } else {
      cell.classList.remove('incomplete');
    }
  }

  function clampDayHours(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 8;
    if (num < 1) return 1;
    if (num > 10) return 10;
    return Math.round(num);
  }

  function formatDayMenuLabel(dateText, worker) {
    if (!dateText) {
      return worker || '';
    }
    if (dayMenuFormatter) {
      try {
        const dt = new Date(`${dateText}T00:00:00`);
        if (!Number.isNaN(dt.valueOf())) {
          return `${dayMenuFormatter.format(dt)} - ${worker}`;
        }
      } catch (err) {
        // ignore formatting errors
      }
    }
    return `${dateText} - ${worker}`;
  }

  function getWorkerDayHours(worker, dateText) {
    if (WORKER_DAY_HOURS && WORKER_DAY_HOURS[worker] && WORKER_DAY_HOURS[worker][dateText] !== undefined) {
      const parsed = Number(WORKER_DAY_HOURS[worker][dateText]);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    }
    if (DAILY_HOURS && DAILY_HOURS[dateText] !== undefined) {
      const parsed = Number(DAILY_HOURS[dateText]);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    }
    return 8;
  }

  function openDayMenu(worker, dateText) {
    if (!dayMenuModal) return;
    dayMenuWorker = worker;
    dayMenuDate = dateText;
    if (dayMenuTitle) {
      dayMenuTitle.textContent = formatDayMenuLabel(dateText, worker);
    }
    if (dayMenuHourSelect) {
      const hoursValue = clampDayHours(getWorkerDayHours(worker, dateText));
      dayMenuHourSelect.value = String(hoursValue);
    }
    dayMenuModal.classList.add('open');
    dayMenuModal.setAttribute('aria-hidden', 'false');
  }

  function closeDayMenu() {
    if (!dayMenuModal) return;
    dayMenuModal.classList.remove('open');
    dayMenuModal.setAttribute('aria-hidden', 'true');
    dayMenuWorker = null;
    dayMenuDate = null;
  }

  function submitDayMenuAction(url, payload, button, errorMessage) {
    if (!url) return;
    if (button) {
      button.disabled = true;
    }
    fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    })
      .then(resp => {
        if (!resp.ok) {
          throw new Error('request failed');
        }
        closeDayMenu();
        window.location.reload();
      })
      .catch(() => {
        alert(errorMessage);
      })
      .finally(() => {
        if (button) {
          button.disabled = false;
        }
      });
  }

  function escapeHtml(value) {
    if (value === undefined || value === null) return '';
    return value
      .toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function normalizePartValue(value) {
    if (value === undefined || value === null) return '';
    const text = `${value}`.trim();
    if (!text) return '';
    const lower = text.toLowerCase();
    if (lower === 'none' || lower === 'null' || lower === 'undefined') return '';
    return text;
  }

  function formatPartSuffix(value) {
    const normalized = normalizePartValue(value);
    if (!normalized) return '';
    const num = Number(normalized);
    if (!Number.isFinite(num)) return '';
    return ` (${Math.trunc(num) + 1})`;
  }

  const historyTimestampFormatter = typeof Intl !== 'undefined'
    ? new Intl.DateTimeFormat('es-ES', {
        timeZone: window.EFIMERO_TZ || 'Europe/Madrid',
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
      })
    : null;

  function formatHistoryTimestamp(value) {
    if (!value) return '';
    if (!historyTimestampFormatter) return value;
    try {
      const dt = new Date(value);
      if (Number.isNaN(dt.valueOf())) return value;
      return historyTimestampFormatter.format(dt);
    } catch (err) {
      return value;
    }
  }

  function formatHistoryDay(value) {
    if (!value) return 'Sin planificar';
    const parts = `${value}`.split('-');
    if (parts.length < 3) return value;
    const month = parts[1].split('T')[0].padStart(2, '0');
    const dayPart = parts[2].split('T')[0];
    const day = dayPart.padStart(2, '0');
    return `${day}/${month}`;
  }

  function formatHistoryWorker(value) {
    const text = value === undefined || value === null ? '' : `${value}`.trim();
    return text || 'Sin planificar';
  }

  function closeHistoryModal() {
    if (!historyModal) return;
    historyModal.classList.remove('open');
    if (historyPositionFrame !== null) {
      cancelAnimationFrame(historyPositionFrame);
      historyPositionFrame = null;
    }
    if (detachHistoryViewport) {
      detachHistoryViewport();
    }
    const content = historyModal.querySelector('.history-content');
    if (content) {
      content.style.left = '';
      content.style.top = '';
      content.style.position = '';
    }
  }

  function renderHistoryEntries(entries) {
    if (!historyList) return;
    if (!Array.isArray(entries) || !entries.length) {
      historyList.innerHTML = '<div class="history-empty">No hay movimientos registrados.</div>';
      scheduleHistoryModalCenter();
      return;
    }
    const html = entries
      .map(entry => {
        const ts = formatHistoryTimestamp(entry.timestamp);
        const fromDay = formatHistoryDay(entry.from_day);
        const toDay = formatHistoryDay(entry.to_day);
        const fromWorker = formatHistoryWorker(entry.from_worker);
        const toWorker = formatHistoryWorker(entry.to_worker);
        return `
          <div class="history-entry">
            <div class="history-entry-time">${ts}</div>
            <div class="history-entry-body">De <strong>${fromDay}</strong> (${fromWorker}) a <strong>${toDay}</strong> (${toWorker})</div>
          </div>
        `;
      })
      .join('');
    historyList.innerHTML = html;
    scheduleHistoryModalCenter();
  }

  function openHistory(pid, phase, part, projectName, clientName) {
    if (!historyModal || !historyList || !HISTORY_URL) return;
    const pieces = [];
    if (projectName) pieces.push(projectName);
    if (clientName) pieces.push(clientName);
    const baseTitle = pieces.length ? pieces.join(' - ') : 'Historial';
    if (historyTitle) {
      const phaseLabel = phase ? `${phase}${formatPartSuffix(part)}` : '';
      const suffix = phaseLabel ? ` (${phaseLabel})` : '';
      historyTitle.textContent = `Historial - ${baseTitle}${suffix}`;
    }
    historyModal.classList.add('open');
    bindHistoryViewportTracking();
    historyList.innerHTML = '<div class="history-loading">Cargando...</div>';
    scheduleHistoryModalCenter();
    const params = new URLSearchParams({ pid, phase });
    if (part) params.append('part', part);
    fetch(`${HISTORY_URL}?${params.toString()}`, {
      method: 'GET',
      credentials: 'same-origin',
    })
      .then(resp => (resp.ok ? resp.json() : Promise.reject()))
      .then(data => {
        const entries = Array.isArray(data.history) ? data.history : [];
        renderHistoryEntries(entries);
        scheduleHistoryModalCenter();
      })
      .catch(() => {
        if (historyList) {
          historyList.innerHTML = '<div class="history-error">No se pudo cargar el historial.</div>';
        }
        scheduleHistoryModalCenter();
      });
  }

  if (historyClose) {
    historyClose.addEventListener('click', ev => {
      ev.stopPropagation();
      closeHistoryModal();
    });
  }
  if (historyModal) {
    historyModal.addEventListener('click', ev => {
      if (ev.target === historyModal) closeHistoryModal();
    });
    const historyContent = historyModal.querySelector('.history-content');
    if (historyContent) {
      historyContent.addEventListener('click', ev => ev.stopPropagation());
    }
  }
  if (dayMenuClose) {
    dayMenuClose.addEventListener('click', ev => {
      ev.preventDefault();
      closeDayMenu();
    });
  }
  if (dayMenuModal) {
    dayMenuModal.addEventListener('click', ev => {
      if (ev.target === dayMenuModal) {
        closeDayMenu();
      }
    });
    const dayMenuContent = dayMenuModal.querySelector('.day-menu-content');
    if (dayMenuContent) {
      dayMenuContent.addEventListener('click', ev => ev.stopPropagation());
    }
  }
  if (dayMenuVacationBtn) {
    dayMenuVacationBtn.addEventListener('click', () => {
      if (!dayMenuWorker || !dayMenuDate) return;
      submitDayMenuAction(
        ASSIGN_VACATION_DAY_URL,
        { worker: dayMenuWorker, date: dayMenuDate },
        dayMenuVacationBtn,
        'No se pudo asignar las vacaciones.'
      );
    });
  }
  if (dayMenuHoursBtn) {
    dayMenuHoursBtn.addEventListener('click', () => {
      if (!dayMenuWorker || !dayMenuDate || !dayMenuHourSelect) return;
      const selected = clampDayHours(dayMenuHourSelect.value);
      submitDayMenuAction(
        UPDATE_WORKER_DAY_HOURS_URL,
        { worker: dayMenuWorker, date: dayMenuDate, hours: selected },
        dayMenuHoursBtn,
        'No se pudo actualizar la jornada.'
      );
    });
  }
  if (dayMenuHourSelect) {
    dayMenuHourSelect.addEventListener('keydown', ev => {
      if (ev.key === 'Enter' && dayMenuHoursBtn) {
        ev.preventDefault();
        dayMenuHoursBtn.click();
      }
    });
  }
  document.querySelectorAll('.schedule').forEach(table => {
    table.addEventListener('contextmenu', ev => {
      const cell = ev.target.closest('td[data-date]');
      if (!cell) {
        return;
      }
      const row = cell.closest('tr[data-worker]');
      if (!row) {
        return;
      }
      ev.preventDefault();
      if (skipNextDayMenu) {
        skipNextDayMenu = false;
        if (skipDayMenuReset) {
          clearTimeout(skipDayMenuReset);
          skipDayMenuReset = null;
        }
        return;
      }
      openDayMenu(row.dataset.worker, cell.dataset.date);
    });
  });
  document.addEventListener('keydown', ev => {
    if (ev.key === 'Escape') {
      closeHistoryModal();
      closeDayMenu();
    }
  });

  function parseSplitHours(value) {
    if (value === undefined || value === null || value === '') return null;
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function toSplitInputValue(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 100) / 100;
    if (Number.isInteger(rounded)) return `${rounded}`;
    return rounded.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
  }

  function formatSplitNumber(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 100) / 100;
    if (Number.isInteger(rounded)) return `${rounded}`;
    return rounded.toLocaleString('es-ES', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
  }

  function formatSplitDuration(value) {
    if (!Number.isFinite(value)) return '';
    const total = value < 0 ? 0 : value;
    const days = Math.floor(total / SPLIT_WORKDAY_HOURS);
    const remainderRaw = total - (days * SPLIT_WORKDAY_HOURS);
    const remainder = Math.round(remainderRaw * 100) / 100;
    const parts = [];
    if (days > 0) parts.push(`${days} día${days === 1 ? '' : 's'}`);
    if (remainder > 0 || parts.length === 0) {
      const hoursText = formatSplitNumber(remainder);
      const hoursLabel = remainder === 1 ? 'hora' : 'horas';
      parts.push(`${hoursText} ${hoursLabel}`);
    }
    return parts.join(' y ');
  }

  function formatSplitHint(value) {
    const duration = formatSplitDuration(value);
    return duration ? `(${duration})` : '';
  }

  function splitOrdinalLabel(index) {
    if (!Number.isInteger(index) || index < 0) return 'Horas parte';
    if (index < SPLIT_ORDINAL_WORDS.length) {
      return `Horas ${SPLIT_ORDINAL_WORDS[index]} parte`;
    }
    return `Horas parte ${index + 1}`;
  }

  function getSplitManualInputs() {
    if (!splitPartsContainer) return [];
    return Array.from(
      splitPartsContainer.querySelectorAll('input.split-part-input[data-manual="true"]')
    );
  }

  function ensureSplitRemainderInput() {
    if (!splitPartsContainer) return null;
    if (splitRemainderInput && splitRemainderInput.isConnected) {
      return splitRemainderInput;
    }
    const row = document.createElement('div');
    row.className = 'split-part-row split-remainder-row';
    const label = document.createElement('label');
    const labelSpan = document.createElement('span');
    labelSpan.className = 'split-part-label';
    label.appendChild(labelSpan);
    const input = document.createElement('input');
    input.type = 'number';
    input.readOnly = true;
    input.tabIndex = -1;
    input.className = 'split-part-input split-part-remainder';
    input.dataset.manual = 'false';
    label.appendChild(input);
    const hint = document.createElement('span');
    hint.className = 'split-hours-hint';
    label.appendChild(hint);
    row.appendChild(label);
    splitPartsContainer.appendChild(row);
    input._hintElement = hint;
    input._labelElement = labelSpan;
    splitRemainderInput = input;
    return splitRemainderInput;
  }

  function refreshSplitPartLabels() {
    const manuals = getSplitManualInputs();
    manuals.forEach((input, idx) => {
      if (input && input._labelElement) {
        input._labelElement.textContent = `${splitOrdinalLabel(idx)}:`;
      }
    });
    if (splitRemainderInput && splitRemainderInput._labelElement) {
      splitRemainderInput._labelElement.textContent = `${splitOrdinalLabel(manuals.length)}:`;
    }
  }

  function createSplitPartRow(initialValue, beforeElement) {
    if (!splitPartsContainer) return null;
    const row = document.createElement('div');
    row.className = 'split-part-row';
    const label = document.createElement('label');
    const labelSpan = document.createElement('span');
    labelSpan.className = 'split-part-label';
    label.appendChild(labelSpan);
    const input = document.createElement('input');
    input.type = 'number';
    input.min = '1';
    input.step = '1';
    input.required = true;
    input.className = 'split-part-input';
    input.dataset.manual = 'true';
    if (initialValue !== null && Number.isFinite(initialValue) && initialValue > 0) {
      input.value = toSplitInputValue(initialValue);
    }
    input.addEventListener('input', () => {
      input.classList.remove('split-input-error');
      updateSplitModalDisplay();
    });
    label.appendChild(input);
    const hint = document.createElement('span');
    hint.className = 'split-hours-hint';
    label.appendChild(hint);
    row.appendChild(label);
    input._hintElement = hint;
    input._labelElement = labelSpan;
    if (beforeElement) {
      splitPartsContainer.insertBefore(row, beforeElement);
    } else {
      splitPartsContainer.appendChild(row);
    }
    return input;
  }

  function resetSplitParts(existingParts) {
    if (!splitPartsContainer) return;
    splitPartsContainer.innerHTML = '';
    splitRemainderInput = null;
    const normalized = Array.isArray(existingParts)
      ? existingParts
          .map(value => parseSplitHours(value))
          .filter(value => Number.isFinite(value) && value > 0)
      : [];
    let manualValues = [];
    let remainderValue = null;
    if (normalized.length >= 2) {
      manualValues = normalized.slice(0, normalized.length - 1);
      remainderValue = normalized[normalized.length - 1];
    } else if (normalized.length === 1) {
      manualValues = [normalized[0]];
    }
    if (!manualValues.length) {
      manualValues = [null];
    }
    manualValues.forEach(value => {
      createSplitPartRow(value, null);
    });
    const remainder = ensureSplitRemainderInput();
    if (remainder) {
      if (remainderValue !== null) {
        remainder.value = toSplitInputValue(remainderValue);
      } else {
        remainder.value = '';
      }
    }
    refreshSplitPartLabels();
    updateSplitModalDisplay();
  }

  function updateSplitModalDisplay() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    if (splitTotalDisplay) {
      if (total === null) {
        splitTotalDisplay.textContent = '';
      } else {
        const baseNumber = formatSplitNumber(total);
        const hoursLabel = total === 1 ? 'hora' : 'horas';
        const duration = formatSplitDuration(total);
        splitTotalDisplay.textContent = `Total fase: ${baseNumber} ${hoursLabel}${duration ? ` (${duration})` : ''}`;
      }
    }
    const manuals = getSplitManualInputs();
    let manualSum = 0;
    manuals.forEach(input => {
      const value = parseSplitHours(input.value);
      if (Number.isFinite(value)) {
        manualSum += value;
      }
      if (input._hintElement) {
        input._hintElement.textContent = Number.isFinite(value) ? formatSplitHint(value) : '';
      }
      if (total !== null && Number.isFinite(total)) {
        input.setAttribute('max', total);
      } else {
        input.removeAttribute('max');
      }
    });
    if (splitRemainderInput) {
      let remainderValue = null;
      if (total !== null && Number.isFinite(total)) {
        remainderValue = total - manualSum;
      }
      if (Number.isFinite(remainderValue)) {
        const cleanValue = Math.max(remainderValue, 0);
        splitRemainderInput.value = toSplitInputValue(cleanValue);
        splitRemainderInput.classList.toggle('split-input-error', remainderValue <= 0);
        if (splitRemainderInput._hintElement) {
          splitRemainderInput._hintElement.textContent = formatSplitHint(cleanValue);
        }
      } else {
        splitRemainderInput.value = '';
        splitRemainderInput.classList.remove('split-input-error');
        if (splitRemainderInput._hintElement) {
          splitRemainderInput._hintElement.textContent = '';
        }
      }
    }
    refreshSplitPartLabels();
  }

  function prepareSplitModal(button) {
    if (!splitModal) return;
    const totalAttr = button ? parseSplitHours(button.dataset.totalHours) : null;
    const fallbackAttr = button ? parseSplitHours(button.dataset.hours) : null;
    let total = totalAttr !== null ? totalAttr : fallbackAttr;
    let existingParts = [];
    if (button) {
      const pid = button.dataset.pid;
      const phase = button.dataset.phase;
      if (pid && phase && PROJECT_DATA[pid] && PROJECT_DATA[pid].phases) {
        const phaseEntry = PROJECT_DATA[pid].phases[phase];
        if (Array.isArray(phaseEntry)) {
          existingParts = phaseEntry;
          const computedTotal = phaseEntry
            .map(value => parseSplitHours(value))
            .filter(value => Number.isFinite(value) && value > 0)
            .reduce((acc, value) => acc + value, 0);
          if (Number.isFinite(computedTotal) && computedTotal > 0) {
            total = computedTotal;
          }
        }
      }
    }
    if (total !== null && Number.isFinite(total)) {
      splitModal.dataset.totalHours = total;
    } else {
      delete splitModal.dataset.totalHours;
    }
    resetSplitParts(existingParts);
    if (fallbackAttr && Number.isFinite(fallbackAttr)) {
      const manuals = getSplitManualInputs();
      if (manuals.length) {
        const first = manuals[0];
        const currentValue = parseSplitHours(first.value);
        if (!(Number.isFinite(currentValue) && Math.abs(currentValue - fallbackAttr) < 1e-6)) {
          first.value = toSplitInputValue(fallbackAttr);
        }
      }
    }
    updateSplitModalDisplay();
    const manuals = getSplitManualInputs();
    if (manuals.length) {
      manuals[0].focus();
    }
  }
  function afterMove(data, originalDate) {
    localStorage.setItem(LAST_KEY, JSON.stringify({pid: data.pid, phase: data.phase, part: data.part, date: data.date}));
    if (data.date !== originalDate) localStorage.setItem(SCROLL_KEY2, data.date);
    location.reload();
  }
  const splitCancel = document.getElementById('split-cancel');
  const filterForm = document.getElementById('filter-form');
  const PROJECT_FILTER = {{ project_filter|tojson }};
  const CLIENT_FILTER = {{ client_filter|tojson }};
  const FILTER_ACTIVE = {{ filter_active|tojson }};
  const projectFilterInput = filterForm ? filterForm.querySelector('input[name="project"]') : null;
  const projectIdField = filterForm ? filterForm.querySelector('input[name="project_id"]') : null;
  if (projectFilterInput && projectIdField) {
    projectFilterInput.addEventListener('input', () => {
      projectIdField.value = '';
    });
  }

  function makeDraggable(el) {
    let startX, startY, startLeft, startTop;
    el.addEventListener('mousedown', e => {
      if (e.target.closest('input, textarea, select, button')) return;
      const rect = el.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startLeft = rect.left + window.scrollX;
      startTop = rect.top + window.scrollY;
      el.style.position = 'absolute';
      el.style.margin = '0';
      el.style.left = startLeft + 'px';
      el.style.top = startTop + 'px';
      function onMove(ev) {
        el.style.left = startLeft + ev.clientX - startX + 'px';
        el.style.top = startTop + ev.clientY - startY + 'px';
      }
      function onUp() {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
      }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }
  document.querySelectorAll('.modal-content, .conflict-content, .info-popup, .history-content').forEach(makeDraggable);

  document.querySelectorAll('.worker-note').forEach(area => {
    area.addEventListener('change', () => {
      fetch(WORKER_NOTE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ worker: area.dataset.worker, text: area.value })
      }).then(r => r.json()).then(data => {
        const t = area.nextElementSibling;
        if (t && data.edited) t.textContent = data.edited;
      });
    });
  });
  const summaryPdfBtn = document.getElementById('summary-pdf-btn');
  if (summaryPdfBtn) {
    const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    async function waitForDocumentFonts(doc, timeoutMs = 8000, label = 'documento') {
      if (!doc || !doc.fonts || typeof doc.fonts.ready !== 'object' || typeof doc.fonts.ready.then !== 'function') {
        return;
      }
      let timedOut = false;
      try {
        await Promise.race([
          doc.fonts.ready,
          new Promise((resolve) => {
            setTimeout(() => {
              timedOut = true;
              resolve();
            }, timeoutMs);
          })
        ]);
      } catch (err) {
        console.warn(`Error esperando a las fuentes (${label}) antes de la captura`, err);
      }
      if (timedOut) {
        console.warn(`Continuando sin esperar más por las fuentes (${label}) tras ${timeoutMs} ms`);
      }
    }

    function elementDimensions(element) {
      if (!element) {
        return { width: 0, height: 0 };
      }
      const rect = typeof element.getBoundingClientRect === 'function'
        ? element.getBoundingClientRect()
        : { width: 0, height: 0 };
      const width = Math.max(
        element.scrollWidth || 0,
        element.offsetWidth || 0,
        element.clientWidth || 0,
        rect.width || 0
      );
      const height = Math.max(
        element.scrollHeight || 0,
        element.offsetHeight || 0,
        element.clientHeight || 0,
        rect.height || 0
      );
      return {
        width: Math.max(1, Math.round(width)),
        height: Math.max(1, Math.round(height))
      };
    }

    function applyScaleTransform(element, scaleFactor) {
      if (!element || !(scaleFactor < 0.999)) {
        return () => {};
      }
      const previousTransform = element.style.transform;
      const previousOrigin = element.style.transformOrigin;
      const hadTransform = element.style.transform !== '';
      const hadOrigin = element.style.transformOrigin !== '';
      element.style.transformOrigin = 'top left';
      element.style.transform = `scale(${scaleFactor})`;
      return () => {
        if (hadTransform) {
          element.style.transform = previousTransform;
        } else {
          element.style.removeProperty('transform');
        }
        if (hadOrigin) {
          element.style.transformOrigin = previousOrigin;
        } else {
          element.style.removeProperty('transform-origin');
        }
      };
    }

    function adjustScrollableAreas(doc, rootElement) {
      const HostHTMLElement = (doc.defaultView && doc.defaultView.HTMLElement) || window.HTMLElement;
      const cleanups = [];
      const seen = new Set();

      function addCandidate(el) {
        if (!el || seen.has(el)) {
          return;
        }
        seen.add(el);
        candidates.push(el);
      }

      const candidates = [];
      const roots = [];
      if (rootElement && rootElement instanceof HostHTMLElement) {
        roots.push(rootElement);
      }
      if (!rootElement) {
        if (doc.body) {
          roots.push(doc.body);
        }
        if (doc.documentElement && doc.documentElement !== doc.body) {
          roots.push(doc.documentElement);
        }
      } else if (rootElement === doc.body || rootElement === doc.documentElement) {
        if (doc.body && rootElement !== doc.body) {
          roots.push(doc.body);
        }
        if (doc.documentElement && rootElement !== doc.documentElement) {
          roots.push(doc.documentElement);
        }
      }

      roots.forEach((root) => {
        addCandidate(root);
        if (root && typeof root.querySelectorAll === 'function') {
          Array.from(root.querySelectorAll('*')).forEach(addCandidate);
        }
      });

      if (!candidates.length) {
        Array.from(doc.querySelectorAll('*')).forEach(addCandidate);
      }

      candidates.forEach((el) => {
        if (!el || typeof el !== 'object') {
          return;
        }
        if (!(el instanceof HostHTMLElement) || el.tagName === 'SCRIPT' || el.tagName === 'STYLE') {
          return;
        }
        const needsWidth = el.scrollWidth > el.clientWidth;
        const needsHeight = el.scrollHeight > el.clientHeight;
        if (!needsWidth && !needsHeight) {
          return;
        }
        const computed = doc.defaultView ? doc.defaultView.getComputedStyle(el) : null;
        if (computed && computed.display === 'inline') {
          return;
        }
        const prev = {
          overflow: el.style.overflow,
          overflowX: el.style.overflowX,
          overflowY: el.style.overflowY,
          maxWidth: el.style.maxWidth,
          maxHeight: el.style.maxHeight,
          width: el.style.width,
          height: el.style.height,
          scrollLeft: el.scrollLeft,
          scrollTop: el.scrollTop
        };
        cleanups.push(() => {
          el.style.overflow = prev.overflow;
          el.style.overflowX = prev.overflowX;
          el.style.overflowY = prev.overflowY;
          el.style.maxWidth = prev.maxWidth;
          el.style.maxHeight = prev.maxHeight;
          el.style.width = prev.width;
          el.style.height = prev.height;
          el.scrollLeft = prev.scrollLeft;
          el.scrollTop = prev.scrollTop;
        });
        el.style.overflow = 'visible';
        el.style.overflowX = 'visible';
        el.style.overflowY = 'visible';
        el.style.maxWidth = 'none';
        el.style.maxHeight = 'none';
        if (needsWidth) {
          el.style.width = `${el.scrollWidth}px`;
          el.scrollLeft = 0;
        }
        if (needsHeight) {
          el.style.height = `${el.scrollHeight}px`;
          el.scrollTop = 0;
        }
      });
      return () => {
        while (cleanups.length) {
          const restore = cleanups.pop();
          try {
            restore();
          } catch (err) {
            console.error('Error restaurando estilos tras captura', err);
          }
        }
      };
    }

    async function captureDocumentCanvas(doc, html2canvasFn, element) {
      const target = element || doc.documentElement || doc.body;
      const cleanup = adjustScrollableAreas(doc, target);
      let restoreScale = () => {};
      try {
        const MAX_CAPTURE_WIDTH = 14000;
        const MAX_CAPTURE_HEIGHT = 16000;
        const MAX_OUTPUT_PX = 10000;
        let dims = elementDimensions(target);
        const scaleCandidates = [];
        if (dims.width > MAX_CAPTURE_WIDTH) {
          scaleCandidates.push(MAX_CAPTURE_WIDTH / dims.width);
        }
        if (dims.height > MAX_CAPTURE_HEIGHT) {
          scaleCandidates.push(MAX_CAPTURE_HEIGHT / dims.height);
        }
        if (scaleCandidates.length) {
          const appliedScale = Math.max(0.25, Math.min(1, ...scaleCandidates));
          restoreScale = applyScaleTransform(target, appliedScale);
          await wait(50);
          const rect = typeof target.getBoundingClientRect === 'function'
            ? target.getBoundingClientRect()
            : null;
          dims = {
            width: Math.max(1, Math.round(rect && rect.width ? rect.width : dims.width * appliedScale)),
            height: Math.max(1, Math.round(rect && rect.height ? rect.height : dims.height * appliedScale))
          };
        }
        const view = doc.defaultView || window;
        const deviceScale = view && typeof view.devicePixelRatio === 'number'
          ? view.devicePixelRatio
          : (typeof window.devicePixelRatio === 'number' ? window.devicePixelRatio : 1);
        const maxScaleByWidth = MAX_OUTPUT_PX / Math.max(1, dims.width);
        const maxScaleByHeight = MAX_OUTPUT_PX / Math.max(1, dims.height);
        const cappedScale = Math.min(2, Math.max(0.5, deviceScale || 1));
        const scale = Math.max(
          0.5,
          Math.min(cappedScale, maxScaleByWidth, maxScaleByHeight)
        );
        return await html2canvasFn(target || doc.body, {
          scale,
          useCORS: true,
          backgroundColor: '#ffffff',
          windowWidth: dims.width,
          windowHeight: dims.height,
          width: dims.width,
          height: dims.height,
          scrollX: -(view?.scrollX || 0),
          scrollY: -(view?.scrollY || 0)
        });
      } finally {
        try {
          restoreScale();
        } catch (err) {
          console.warn('No se pudo restaurar el escalado tras la captura', err);
        }
        cleanup();
      }
    }

    async function captureCurrentPage(html2canvasFn) {
      const originalScroll = { x: window.scrollX, y: window.scrollY };
      window.scrollTo(0, 0);
      try {
        await waitForDocumentFonts(document, 8000, 'pestaña actual');
        const targets = [];
        const preferredSelectors = [
          '.complete-container',
          'main',
          '#content',
          '.content',
        ];
        preferredSelectors.forEach((selector) => {
          const el = document.querySelector(selector);
          if (el && !targets.includes(el)) {
            targets.push(el);
          }
        });
        const body = document.body;
        const docEl = document.documentElement;
        if (body && !targets.includes(body)) targets.push(body);
        if (docEl && !targets.includes(docEl)) targets.push(docEl);
        for (const target of targets) {
          const canvas = await captureWithRetry(
            () => captureDocumentCanvas(document, html2canvasFn, target),
            3,
            400,
            20000
          );
          if (canvas) {
            return canvas;
          }
        }
        return null;
      } finally {
        window.scrollTo(originalScroll.x, originalScroll.y);
      }
    }

    async function captureExternalPage(url, html2canvasFn) {
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.position = 'fixed';
      iframe.style.left = '-100000px';
      iframe.style.top = '0';
      iframe.style.width = '1400px';
      iframe.style.height = '900px';
      iframe.style.opacity = '0';
      iframe.style.pointerEvents = 'none';
      iframe.setAttribute('aria-hidden', 'true');
      document.body.appendChild(iframe);
      try {
        await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('Timeout cargando pestaña'));
          }, 20000);
          iframe.onload = () => {
            clearTimeout(timeout);
            resolve();
          };
          iframe.onerror = () => {
            clearTimeout(timeout);
            reject(new Error('Error cargando pestaña'));
          };
        });
        const iframeWindow = iframe.contentWindow;
        const iframeDoc = iframeWindow.document;
        iframeWindow.scrollTo(0, 0);
        await wait(1000);
        await waitForDocumentFonts(iframeDoc, 8000, 'pestaña remota');
        const targets = [];
        const preferredSelectors = [
          '.complete-container',
          '.pedidos-calendar-container',
          '.kanban',
          '.kanban-container',
          '.gantt-container',
          '.gantt-wrapper',
          '.vacations-container',
          '.resources-container',
          '.observations-container',
          'main',
          '#content',
          '.content'
        ];
        preferredSelectors.forEach((selector) => {
          const el = iframeDoc.querySelector(selector);
          if (el && !targets.includes(el)) {
            targets.push(el);
          }
        });
        if (iframeDoc.body && !targets.includes(iframeDoc.body)) {
          targets.push(iframeDoc.body);
        }
        if (iframeDoc.documentElement && !targets.includes(iframeDoc.documentElement)) {
          targets.push(iframeDoc.documentElement);
        }
        for (const target of targets) {
          const canvas = await captureWithRetry(
            () => captureDocumentCanvas(iframeDoc, html2canvasFn, target),
            3,
            400,
            22000
          );
          if (canvas) {
            return canvas;
          }
        }
        return null;
      } finally {
        iframe.remove();
      }
    }

    function collectPlannerPages() {
      const navLinks = Array.from(document.querySelectorAll('nav a'));
      const seen = new Set();
      const pages = [];
      const currentPath = window.location.pathname;
      navLinks.forEach((link) => {
        const url = new URL(link.href, window.location.href);
        if (seen.has(url.pathname)) {
          return;
        }
        seen.add(url.pathname);
        pages.push({
          title: link.textContent.trim() || url.pathname,
          url: url.href,
          pathname: url.pathname,
          isCurrent: url.pathname === currentPath
        });
      });
      pages.sort((a, b) => {
        if (a.isCurrent) return -1;
        if (b.isCurrent) return 1;
        return 0;
      });
      return pages;
    }

    function createProgressBanner() {
      const banner = document.createElement('div');
      banner.className = 'pdf-progress-banner';
      banner.textContent = 'Preparando PDF…';
      document.body.appendChild(banner);
      return banner;
    }

    function updateProgress(banner, index, total, title) {
      if (!banner) return;
      banner.textContent = `Generando PDF (${index}/${total}) · ${title}`;
    }

    async function reportPdfError(error) {
      const payload = {
        message: error && typeof error.message === 'string' ? error.message : String(error),
        stack: error && typeof error.stack === 'string' ? error.stack : undefined,
      };
      try {
        await fetch('/client-error', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify(payload),
        });
      } catch (reportErr) {
        console.error('Error enviando el reporte del PDF', reportErr);
      }
    }

    function canvasToDataUrl(canvas, type = 'image/jpeg', quality = 0.85) {
      return new Promise((resolve, reject) => {
        const fallbackToDataUrl = () => {
          try {
            const dataUrl = canvas.toDataURL(type, quality);
            if (typeof dataUrl === 'string') {
              resolve(dataUrl);
            } else {
              reject(new Error('No se pudo generar la imagen del PDF'));
            }
          } catch (fallbackError) {
            reject(fallbackError);
          }
        };

        try {
          if (typeof canvas.toBlob === 'function') {
            canvas.toBlob((blob) => {
              if (!blob) {
                fallbackToDataUrl();
                return;
              }
              const reader = new FileReader();
              reader.onloadend = () => {
                if (typeof reader.result === 'string') {
                  resolve(reader.result);
                } else {
                  reject(new Error('Resultado de imagen inválido'));
                }
              };
              reader.onerror = () => {
                fallbackToDataUrl();
              };
              reader.readAsDataURL(blob);
            }, type, quality);
            return;
          }

          fallbackToDataUrl();
        } catch (blobError) {
          reject(blobError);
        }
      });
    }

    function isCanvasMostlyBlank(canvas) {
      if (!canvas || !canvas.width || !canvas.height) {
        return true;
      }

      const width = canvas.width;
      const height = canvas.height;
      const totalPixels = width * height;
      const WHITE_THRESHOLD = 245;
      const ALPHA_THRESHOLD = 16;
      const MAX_PREVIEW_PIXELS = 40000; // ~200x200

      try {
        const scale = totalPixels > MAX_PREVIEW_PIXELS
          ? Math.sqrt(MAX_PREVIEW_PIXELS / totalPixels)
          : 1;
        const previewWidth = Math.max(1, Math.round(width * scale));
        const previewHeight = Math.max(1, Math.round(height * scale));
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = previewWidth;
        previewCanvas.height = previewHeight;
        const previewCtx = previewCanvas.getContext('2d');
        if (previewCtx) {
          previewCtx.imageSmoothingEnabled = true;
          previewCtx.drawImage(canvas, 0, 0, previewWidth, previewHeight);
          const data = previewCtx.getImageData(0, 0, previewWidth, previewHeight).data;
          for (let i = 0; i < data.length; i += 4) {
            const alpha = data[i + 3];
            if (alpha > ALPHA_THRESHOLD) {
              if (data[i] < WHITE_THRESHOLD || data[i + 1] < WHITE_THRESHOLD || data[i + 2] < WHITE_THRESHOLD) {
                return false;
              }
            }
          }
        }
      } catch (previewError) {
        console.warn('No se pudo analizar la miniatura del canvas', previewError);
      }

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return true;
      }

      const targetSamples = Math.min(2500, Math.max(100, Math.floor(totalPixels / 4000)));
      const step = Math.max(1, Math.floor(Math.sqrt(totalPixels / targetSamples)));

      const samplePositions = [];
      const pushSample = (x, y) => {
        const clampedX = Math.min(width - 1, Math.max(0, Math.round(x)));
        const clampedY = Math.min(height - 1, Math.max(0, Math.round(y)));
        samplePositions.push([clampedX, clampedY]);
      };

      for (let y = 0; y < height; y += step) {
        for (let x = 0; x < width; x += step) {
          pushSample(x, y);
          if (step > 4) {
            pushSample(x + Math.floor(step / 2), y + Math.floor(step / 2));
          }
        }
      }

      pushSample(width / 2, height / 2);
      pushSample(width / 4, height / 4);
      pushSample((3 * width) / 4, height / 4);
      pushSample(width / 4, (3 * height) / 4);
      pushSample((3 * width) / 4, (3 * height) / 4);
      pushSample(width - 1, height - 1);

      const seen = new Set();
      for (let i = 0; i < samplePositions.length; i += 1) {
        const [sx, sy] = samplePositions[i];
        const key = `${sx},${sy}`;
        if (seen.has(key)) {
          continue;
        }
        seen.add(key);
        const pixel = ctx.getImageData(sx, sy, 1, 1).data;
        const alpha = pixel[3];
        if (alpha > ALPHA_THRESHOLD) {
          if (pixel[0] < WHITE_THRESHOLD || pixel[1] < WHITE_THRESHOLD || pixel[2] < WHITE_THRESHOLD) {
            return false;
          }
        }
      }
      return true;
    }

    async function captureWithRetry(captureFn, attempts = 2, delayMs = 300, timeoutMs = 20000) {
      let lastCanvas = null;
      const timeoutToken = Symbol('capture-timeout');
      for (let attempt = 0; attempt < attempts; attempt += 1) {
        try {
          const result = await Promise.race([
            captureFn(),
            wait(timeoutMs).then(() => timeoutToken)
          ]);
          if (result === timeoutToken) {
            console.warn(`Captura excedió ${timeoutMs} ms; reintentando…`);
          } else {
            lastCanvas = result;
          }
        } catch (err) {
          console.warn('Error capturando el contenido', err);
        }
        if (lastCanvas && !isCanvasMostlyBlank(lastCanvas)) {
          return lastCanvas;
        }
        if (attempt < attempts - 1) {
          await wait(delayMs);
        }
      }
      if (lastCanvas && isCanvasMostlyBlank(lastCanvas)) {
        console.warn('La captura parece vacía tras varios intentos; usando el último resultado disponible.');
      }
      return lastCanvas;
    }

    function scaleCanvasForPdf(canvas) {
      const MAX_WIDTH = 1800;
      if (!canvas || canvas.width <= MAX_WIDTH) {
        return canvas;
      }
      const ratio = MAX_WIDTH / canvas.width;
      const target = document.createElement('canvas');
      target.width = Math.max(1, Math.round(canvas.width * ratio));
      target.height = Math.max(1, Math.round(canvas.height * ratio));
      const ctx = target.getContext('2d');
      if (!ctx) {
        return canvas;
      }
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(canvas, 0, 0, target.width, target.height);
      return target;
    }

    async function appendCanvasToPdf(pdf, canvas, isFirstPage) {
      const workingCanvas = scaleCanvasForPdf(canvas);
      if (!workingCanvas || !workingCanvas.width || !workingCanvas.height) {
        return isFirstPage;
      }
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const imgWidth = pageWidth;
      const scale = imgWidth / workingCanvas.width;
      const pageHeightPx = Math.max(1, Math.floor(pageHeight / scale));
      const sliceCanvas = document.createElement('canvas');
      sliceCanvas.width = workingCanvas.width;
      let pageAdded = false;
      for (let y = 0, sliceIndex = 0; y < workingCanvas.height; y += pageHeightPx, sliceIndex += 1) {
        const sliceHeight = Math.min(pageHeightPx, workingCanvas.height - y);
        sliceCanvas.height = sliceHeight;
        const ctx = sliceCanvas.getContext('2d');
        if (!ctx) {
          break;
        }
        ctx.clearRect(0, 0, sliceCanvas.width, sliceCanvas.height);
        ctx.drawImage(
          workingCanvas,
          0,
          y,
          workingCanvas.width,
          sliceHeight,
          0,
          0,
          sliceCanvas.width,
          sliceHeight
        );
        const imageData = await canvasToDataUrl(sliceCanvas);
        if (sliceIndex > 0 || !isFirstPage) {
          pdf.addPage();
        }
        pdf.addImage(imageData, 'JPEG', 0, 0, imgWidth, sliceHeight * scale);
        isFirstPage = false;
        pageAdded = true;
      }
      return pageAdded ? false : isFirstPage;
    }

    summaryPdfBtn.addEventListener('click', async () => {
      const html2canvasFn = window.html2canvas;
      const jspdfNS = window.jspdf || {};
      const { jsPDF } = jspdfNS;
      if (typeof html2canvasFn !== 'function' || typeof jsPDF !== 'function') {
        alert('No se pudo cargar el generador de PDF. Recarga la página e inténtalo de nuevo.');
        return;
      }
      const pages = collectPlannerPages();
      if (!pages.length) {
        alert('No se encontraron pestañas para generar el PDF.');
        return;
      }
      const originalLabel = summaryPdfBtn.textContent;
      summaryPdfBtn.disabled = true;
      const progressBanner = createProgressBanner();
      const pdf = new jsPDF('p', 'mm', 'a4');
      let firstPage = true;
      try {
        for (let i = 0; i < pages.length; i += 1) {
          const page = pages[i];
          summaryPdfBtn.textContent = `Generando… (${i + 1}/${pages.length})`;
          updateProgress(progressBanner, i + 1, pages.length, page.title);
          const canvas = page.isCurrent
            ? await captureCurrentPage(html2canvasFn)
            : await captureExternalPage(page.url, html2canvasFn);
          if (!canvas) {
            throw new Error(`No se pudo capturar la pestaña "${page.title}"`);
          }
          firstPage = await appendCanvasToPdf(pdf, canvas, firstPage);
        }
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const filename = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.pdf`;
        pdf.save(filename);
      } catch (error) {
        console.error('Error generando el PDF', error);
        await reportPdfError(error);
        alert('No se pudo generar el PDF. Inténtalo de nuevo más tarde.');
      } finally {
        summaryPdfBtn.disabled = false;
        summaryPdfBtn.textContent = originalLabel;
        if (progressBanner) {
          progressBanner.remove();
        }
      }
    });
  }
  const hoursBtn = document.getElementById('hours-btn');
  const hoursRow = document.getElementById('hours-row');
  const thead = document.querySelector('.schedule thead');
  function toggleHours() {
    const open = hoursRow.style.display !== 'none';
    hoursRow.style.display = open ? 'none' : 'table-row';
    thead.classList.toggle('open', !open);
  }
  if (hoursBtn) {
    hoursBtn.addEventListener('click', toggleHours);
  }
  document.querySelectorAll('.hours-form').forEach(f => {
    f.addEventListener('change', () => {
      const val = f.querySelector('select').value;
      sessionStorage.setItem(SCROLL_KEY, wrapper.scrollLeft);
      fetch(HOURS_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ date: f.dataset.date, hours: val })
      }).then(resp => {
        if (resp.ok) { location.reload(); } else { alert('Error'); }
      });
    });
  });
  const wrapper = document.querySelector('.schedule-wrapper');
  const SCROLL_KEY = 'calendarScroll';

  function restoreScrollPosition() {
    const savedScroll = sessionStorage.getItem(SCROLL_KEY);
    if (savedScroll !== null) {
      wrapper.scrollLeft = parseFloat(savedScroll);
    } else {
      const todayCell = document.querySelector('th.today');
      if (todayCell) todayCell.scrollIntoView({behavior: 'auto', inline: 'center'});
    }
  }

  if (FILTER_ACTIVE) {
    const matchingTasks = Array.from(document.querySelectorAll('.schedule .task[data-filter-match="true"]'));
    let earliestTask = null;
    let earliestDate = null;
    matchingTasks.forEach(t => {
      const value = t.dataset.day;
      if (!value) return;
      const dt = new Date(value);
      if (Number.isNaN(dt.getTime())) return;
      if (!earliestDate || dt < earliestDate) {
        earliestDate = dt;
        earliestTask = t;
      }
    });
    if (earliestTask) {
      earliestTask.scrollIntoView({behavior: 'auto', inline: 'center'});
    } else {
      restoreScrollPosition();
    }
  } else {
    restoreScrollPosition();
  }
  wrapper.addEventListener('scroll', () => {
    sessionStorage.setItem(SCROLL_KEY, wrapper.scrollLeft);
  });
  wrapper.addEventListener('wheel', (e) => {
    if (!e.shiftKey) return;
    e.preventDefault();
    wrapper.scrollLeft += e.deltaY;
  });

  let isDragScrolling = false;
  let dragStartX = 0;
  let dragStartScroll = 0;
  let dragWithRightButton = false;
  let suppressContextMenu = false;
  let dragMoved = false;
  let skipNextDayMenu = false;
  let skipDayMenuReset = null;

  function stopDragScroll() {
    if (!isDragScrolling && !suppressContextMenu) return;
    if (dragWithRightButton && dragMoved) {
      skipNextDayMenu = true;
      if (skipDayMenuReset) {
        clearTimeout(skipDayMenuReset);
      }
      skipDayMenuReset = setTimeout(() => {
        skipNextDayMenu = false;
        skipDayMenuReset = null;
      }, 200);
    }
    isDragScrolling = false;
    if (suppressContextMenu) {
      setTimeout(() => { suppressContextMenu = false; }, 0);
    }
    dragWithRightButton = false;
    dragMoved = false;
    wrapper.classList.remove('dragging');
  }

  wrapper.addEventListener('mousedown', (e) => {
    const wantsShiftDrag = e.button === 0 && e.shiftKey;
    const wantsRightDrag = e.button === 2;
    if (!wantsShiftDrag && !wantsRightDrag) return;
    dragStartX = e.clientX;
    dragStartScroll = wrapper.scrollLeft;
    isDragScrolling = true;
    dragWithRightButton = wantsRightDrag;
    suppressContextMenu = wantsRightDrag;
    dragMoved = false;
    if (wantsRightDrag && skipDayMenuReset) {
      clearTimeout(skipDayMenuReset);
      skipDayMenuReset = null;
      skipNextDayMenu = false;
    }
    wrapper.classList.add('dragging');
    e.preventDefault();
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragScrolling) return;
    const requiredButton = dragWithRightButton ? 2 : 1;
    if ((e.buttons & requiredButton) === 0) {
      stopDragScroll();
      return;
    }
    const delta = e.clientX - dragStartX;
    if (!dragMoved && Math.abs(delta) > 2) {
      dragMoved = true;
    }
    wrapper.scrollLeft = dragStartScroll - delta;
  });

  window.addEventListener('mouseup', (e) => {
    if (!isDragScrolling) return;
    if (e.button !== 0 && e.button !== 2) return;
    stopDragScroll();
  });

  window.addEventListener('blur', stopDragScroll);

  wrapper.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (suppressContextMenu || isDragScrolling) {
      return;
    }
  });
  const todayBtn = document.getElementById('today-btn');
  if (todayBtn) {
    todayBtn.addEventListener('click', () => {
      const todayCell = document.querySelector('th.today');
      if (todayCell) todayCell.scrollIntoView({behavior: 'smooth', inline: 'center'});
    });
  }

  const sortDueBtn = document.getElementById('sort-due-btn');
  const sortStatusBtn = document.getElementById('sort-status-btn');
  const orderLists = document.querySelectorAll('.unplanned-list[data-mode]');
  const ORDER_KEY = 'unplannedOrderMode';
  const ORDER_STATUS = 'status';
  const ORDER_DUE = 'due';

  function applyUnplannedOrder(mode) {
    const selected = mode === ORDER_DUE ? ORDER_DUE : ORDER_STATUS;
    orderLists.forEach((list) => {
      const active = list.dataset.mode === selected;
      list.style.display = active ? 'block' : 'none';
      list.classList.toggle('active', active);
    });
    if (sortDueBtn) sortDueBtn.classList.toggle('active', selected === ORDER_DUE);
    if (sortStatusBtn) sortStatusBtn.classList.toggle('active', selected === ORDER_STATUS);
    localStorage.setItem(ORDER_KEY, selected);
  }

  const savedOrder = localStorage.getItem(ORDER_KEY);
  const initialOrder = savedOrder === ORDER_DUE ? ORDER_DUE : ORDER_STATUS;
  if (sortDueBtn) {
    sortDueBtn.addEventListener('click', () => applyUnplannedOrder(ORDER_DUE));
  }
  if (sortStatusBtn) {
    sortStatusBtn.addEventListener('click', () => applyUnplannedOrder(ORDER_STATUS));
  }
  if (orderLists.length) {
    applyUnplannedOrder(initialOrder);
  }

const tasks = document.querySelectorAll('.task');
const folders = document.querySelectorAll('.unplanned-folder');
const popup = document.getElementById('info-popup');
let lastDrag = null;
let dragInfo = null;
let draggedTaskElement = null;
  tasks.forEach(t => {
    t.addEventListener('dragstart', e => {
      if (t.dataset.archived === 'true') {
        e.preventDefault();
        return;
      }
      popup.style.display = 'none';
      const row = t.closest('[data-worker]');
      const partValue = normalizePartValue(t.dataset.part);
      const manualSource = !!t.closest('#manual-dropzone');
      lastDrag = {
        pid: t.dataset.pid,
        phase: t.dataset.phase,
        date: t.dataset.day,
        worker: row ? row.dataset.worker : '',
        part: partValue
      };
      dragInfo = { pid: t.dataset.pid, phase: t.dataset.phase, part: partValue, manual: manualSource };
      draggedTaskElement = t;
      e.dataTransfer.setData('text/plain', JSON.stringify({pid: t.dataset.pid, phase: t.dataset.phase, part: partValue}));
    });
    t.addEventListener('dragend', () => { dragInfo = null; draggedTaskElement = null; });
    t.addEventListener('click', (e) => {
      e.stopPropagation();
      const proj = t.dataset.project;
      tasks.forEach(o => {
        if (o.dataset.project === proj) {
          o.classList.add('highlight');
          o.classList.remove('dim');
        } else {
          o.classList.add('dim');
          o.classList.remove('highlight');
        }
      });
      folders.forEach(f => {
        if (f.dataset.pid === t.dataset.pid) {
          f.classList.remove('dim');
        } else {
          f.classList.add('dim');
        }
      });
      document.querySelectorAll('.projects-table tbody tr[data-pid]').forEach(row => {
        if (row.dataset.pid === t.dataset.pid) {
          row.classList.add('proj-highlight');
          row.classList.remove('proj-dim');
        } else {
          row.classList.add('proj-dim');
          row.classList.remove('proj-highlight');
        }
      });
      const infoRaw = PROJECT_DATA[t.dataset.pid] || {};
      const info = (infoRaw && typeof infoRaw === 'object') ? infoRaw : {};
      const isArchivedShadow = t.dataset.archived === 'true' || !!info.archived_shadow;
      const normalizedPart = normalizePartValue(t.dataset.part);
      const phasePartSuffix = formatPartSuffix(t.dataset.part);
      const displayName = info.name || t.dataset.project;
      const displayClient = info.client || t.dataset.client;
      const blockedBadge = info.blocked ? ' <span class="blocked-sign">\u{1F6AB}</span>' : '';
      let html = `<div class="popup-section popup-header"><strong>${displayName}${blockedBadge} - ${displayClient} - ${t.dataset.phase}${phasePartSuffix}</strong></div>`;
      const startMap = START_DATA[t.dataset.pid] || {};
      const startVal = startMap[t.dataset.phase] || '';
      const metaLines = [];
      const status = (info.material_status || '').toString();
      if (status === 'missing') {
        const missingTitles = Array.isArray(info.material_missing_titles)
          ? info.material_missing_titles.filter(title => title && `${title}`.trim() !== '')
          : [];
        if (missingTitles.length) {
          const items = missingTitles
            .map(title => `<li>${escapeHtml(title)}</li>`)
            .join('');
          metaLines.push(`<div class="material-status-missing-block"><strong class="material-status-flag material-status-missing">FALTA MATERIAL</strong><ul class="material-status-missing-list">${items}</ul></div>`);
        } else {
          metaLines.push('<div><strong class="material-status-flag material-status-missing">FALTA MATERIAL</strong></div>');
        }
      } else if (status === 'pending') {
        metaLines.push('<div><strong class="material-status-flag material-status-pending">MATERIAL POR PEDIR</strong></div>');
      } else if (status === 'verify') {
        metaLines.push('<div><strong class="material-status-flag material-status-verify">SOLO FALTA VERIFICAR MATERIAL</strong></div>');
      } else if (status === 'archived' || isArchivedShadow) {
        metaLines.push('<div><strong class="material-status-flag material-status-archived">MATERIAL ARCHIVADO</strong></div>');
      } else if (status) {
        metaLines.push('<div><strong class="material-status-flag material-status-complete">MATERIAL COMPLETO</strong></div>');
      }
      if (info.due_date && info.due_date !== '0') metaLines.push(`<div>Límite: ${info.due_date}</div>`);
      if (info.material_confirmed_date && info.material_confirmed_date !== '0') metaLines.push(`<div>Material confirmado: ${info.material_confirmed_date}</div>`);
      if (!metaLines.length && isArchivedShadow) {
        metaLines.push('<div><strong class="material-status-flag material-status-archived">MATERIAL ARCHIVADO</strong></div>');
      }
      if (metaLines.length) html += `<div class="popup-section">${metaLines.join('')}</div>`;
      const kanbanFields = info.kanban_display_fields || {};
      const kanbanEntries = Object.entries(kanbanFields).filter(([, value]) => value !== null && value !== undefined && `${value}`.trim() !== '');
      let addedPedidosButton = false;
      if (kanbanEntries.length) {
        let kanbanHtml = '<div class="popup-section kanban-extra-fields">';
        kanbanEntries.forEach(([label, value]) => {
          const displayValue = `${value}`;
          kanbanHtml += `<div>${label}: ${displayValue}</div>`;
          if (!addedPedidosButton) {
            const normalizedLabel = (label || '').toString().trim().toLowerCase();
            if (normalizedLabel === 'estado pedidos' || normalizedLabel === 'estado de los pedidos') {
              const safeProjectAttr = escapeHtml(info.name || t.dataset.project || '');
              const safePidAttr = escapeHtml(t.dataset.pid || '');
              kanbanHtml += `<div><button type="button" class="view-pedidos-btn" data-project="${safeProjectAttr}" data-pid="${safePidAttr}">Ver pedidos</button></div>`;
              addedPedidosButton = true;
            }
          }
        });
        if (!addedPedidosButton) {
          const safeProjectAttr = escapeHtml(info.name || t.dataset.project || '');
          const safePidAttr = escapeHtml(t.dataset.pid || '');
          kanbanHtml += `<div><button type="button" class="view-pedidos-btn" data-project="${safeProjectAttr}" data-pid="${safePidAttr}">Ver pedidos</button></div>`;
          addedPedidosButton = true;
        }
        kanbanHtml += '</div>';
        html += kanbanHtml;
      }
      if (!addedPedidosButton) {
        const safeProjectAttr = escapeHtml(info.name || t.dataset.project || '');
        const safePidAttr = escapeHtml(t.dataset.pid || '');
        html += `<div class="popup-section kanban-extra-fields"><div><button type="button" class="view-pedidos-btn" data-project="${safeProjectAttr}" data-pid="${safePidAttr}">Ver pedidos</button></div></div>`;
        addedPedidosButton = true;
      }
      const projectPhases = info.phases || {};
      const assignedMap = info.assigned || {};
      const phaseLines = [];
      PHASES.forEach(ph => {
        if (ph === 'dibujo' || ph === 'pedidos') return;
        const val = projectPhases[ph];
        let total = 0;
        if (Array.isArray(val)) total = val.map(v => parseInt(v)).reduce((a,b) => a + b, 0);
        else total = parseInt(val) || 0;
        if (total > 0) {
          const assigned = assignedMap[ph] || 'Sin planificar';
          const classes = ['phase-entry'];
          classes.push(assigned === 'Sin planificar' ? 'unplanned' : 'planned');
          const isActivePhase = ph === t.dataset.phase;
          const partSuffix = isActivePhase ? phasePartSuffix : '';
          let line = `<div class="${classes.join(' ')}">${ph}${partSuffix}: ${total}h`;
          if (isActivePhase) {
            const partValue = normalizedPart;
            const partAttr = partValue ? ` data-part="${partValue}"` : '';
            line += ` <form id="phase-hours-form" style="display:inline"><input type="number" id="phase-hours-input" value="${total}" min="1" required><button type="submit" id="phase-hours-btn" data-pid="${t.dataset.pid}" data-phase="${ph}"${partAttr}>Cambiar horas</button></form>`;
          }
          line += `</div>`;
          phaseLines.push(line);
        }
      });
      let phaseSection = '';
      if (phaseLines.length) phaseSection += phaseLines.join('');
      if (t.dataset.phase === 'pedidos') {
        const acopio = projectPhases['pedidos'];
        if (acopio && acopio !== '0') phaseSection += `<div>Plazo acopio: ${acopio}</div>`;
      }
      if (phaseSection) html += `<div class="popup-section">${phaseSection}</div>`;
      const actionLines = [];
      const historyPartAttr = normalizedPart ? ` data-part="${normalizedPart}"` : '';
      actionLines.push(`<div><button type="button" class="history-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}"${historyPartAttr}>Historial</button></div>`);
      if (!isArchivedShadow) {
        actionLines.push(`<div>Inicio de la fase: <form id="start-form" style="display:inline"><input type="date" id="start-input" value="${startVal}" required><button type="submit" id="start-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}">Cambiar</button></form></div>`);
        actionLines.push(`<div><button id="freeze-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}" style="color:red;font-weight:bold">${(info.frozen_phases && info.frozen_phases.includes(t.dataset.phase)) ? 'Descongelar' : 'Congelar'}</button></div>`);
        const phaseHoursEntry = (info.phases && info.phases[t.dataset.phase]) || null;
        let totalPhaseHours = null;
        if (Array.isArray(phaseHoursEntry)) {
          totalPhaseHours = phaseHoursEntry
            .map(v => Number(v) || 0)
            .reduce((acc, val) => acc + val, 0);
        } else if (phaseHoursEntry !== undefined && phaseHoursEntry !== null && `${phaseHoursEntry}`.trim() !== '') {
          const parsedPhase = Number(phaseHoursEntry);
          if (Number.isFinite(parsedPhase)) totalPhaseHours = parsedPhase;
        } else if (t.dataset.hours) {
          const parsedDataset = Number(t.dataset.hours);
          if (Number.isFinite(parsedDataset)) totalPhaseHours = parsedDataset;
        }
        const totalHoursAttr = totalPhaseHours !== null ? ` data-total-hours="${totalPhaseHours}"` : '';
        const partHoursAttr = t.dataset.hours ? ` data-hours="${t.dataset.hours}"` : '';
        let splitLine = `<div><button id="split-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}" data-date="${t.dataset.day}"${totalHoursAttr}${partHoursAttr}>Dividir fase aquí</button>`;
        if (Array.isArray(projectPhases[t.dataset.phase])) {
          splitLine += ` <button id="unsplit-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}">Deshacer división</button>`;
        }
        splitLine += `</div>`;
        actionLines.push(splitLine);
        actionLines.push(`<div><button class="phase-delete-btn" id="del-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}">&#10060; Borrar fase</button></div>`);
        const unplanPart = normalizedPart;
        const unplanAttr = unplanPart ? ` data-part="${unplanPart}"` : '';
        actionLines.push(`<div><button id="unplan-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}"${unplanAttr}>Sin planificar</button></div>`);
        const obsValue = info && info.observations !== undefined && info.observations !== null
          ? `${info.observations}`
          : '';
        const safeObsValue = escapeHtml(obsValue);
        actionLines.push(`
          <div class="popup-observations">
            <label for="obs-text">Observaciones</label>
            <textarea id="obs-text" data-pid="${t.dataset.pid}" class="popup-observations-text">${safeObsValue}</textarea>
            <div class="popup-observations-actions">
              <button type="button" id="obs-save" data-pid="${t.dataset.pid}">Guardar</button>
            </div>
          </div>
        `);
      } else {
        const kanbanColumn = ((info && info.kanban_column) || '').toString().trim().toLowerCase();
        if (kanbanColumn === 'ready to archive') {
          const archivePartAttr = normalizedPart ? ` data-part="${normalizedPart}"` : '';
          actionLines.push(`<div><button type="button" class="remove-archived-phase-btn" data-pid="${t.dataset.pid}" data-phase="${t.dataset.phase}"${archivePartAttr}>Eliminar fase archivada</button></div>`);
        }
        if (info && info.observations) {
          const safeObsValue = escapeHtml(`${info.observations}`);
          actionLines.push(`<div class="popup-section"><strong>Observaciones</strong><div>${safeObsValue}</div></div>`);
        }
        actionLines.push('<div class="popup-section popup-readonly">Proyecto archivado en Kanbanize. Acciones limitadas.</div>');
      }
      if (info.image) {
          const imgUrl = `${STATIC_URL}${info.image}`;
          actionLines.push(`<div><a href="${imgUrl}" target="_blank"><img src="${imgUrl}" style="max-width:200px;display:block;margin-top:4px;"></a></div>`);
        }
        if (info.kanban_attachments && info.kanban_attachments.length) {
          info.kanban_attachments.forEach(att => {
            const url = att.url;
            const name = (att.name || '').toLowerCase();
            if (/\.(png|jpe?g|gif|webp|bmp|svg)$/.test(name)) {
              actionLines.push(`<div><a href="${url}" target="_blank"><img src="${url}" alt="${att.name || ''}" style="max-width:200px;display:block;margin-top:4px;"></a></div>`);
            } else {
              actionLines.push(`<div><a href="${url}" target="_blank">${att.name || url}</a></div>`);
            }
          });
        }
        if (actionLines.length) html += `<div class="popup-section">${actionLines.join('')}</div>`;
      popup.innerHTML = html;
      const rect = t.getBoundingClientRect();
      popup.style.left = (rect.left + window.scrollX + 5) + 'px';
      popup.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      popup.style.display = 'block';
      const historyBtn = popup.querySelector('.history-btn');
      const viewPedidosBtn = popup.querySelector('.view-pedidos-btn');
      if (historyBtn) {
        historyBtn.addEventListener('click', ev => {
          ev.stopPropagation();
          const partValue = normalizePartValue(historyBtn.dataset.part);
          openHistory(historyBtn.dataset.pid, historyBtn.dataset.phase, partValue, displayName, displayClient);
        });
      }
      if (viewPedidosBtn) {
        viewPedidosBtn.addEventListener('click', ev => {
          ev.stopPropagation();
          try {
            const url = new URL(CALENDAR_PEDIDOS_URL, window.location.origin);
            const projectName = viewPedidosBtn.dataset.project || '';
            if (projectName) url.searchParams.set('filter', projectName);
            const pidValue = viewPedidosBtn.dataset.pid || '';
            if (pidValue) url.searchParams.set('highlight', pidValue);
            window.open(url.toString(), '_blank');
          } catch (error) {
            console.error('No se pudo abrir Calendario pedidos:', error);
          }
        });
      }
      const removeArchivedBtn = popup.querySelector('.remove-archived-phase-btn');
      if (removeArchivedBtn) {
        removeArchivedBtn.addEventListener('click', ev => {
          ev.stopPropagation();
          if (!confirm('¿Eliminar esta fase archivada del calendario?')) return;
          const payload = { pid: removeArchivedBtn.dataset.pid, phase: removeArchivedBtn.dataset.phase };
          fetch(REMOVE_ARCHIVED_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload)
          })
            .then(resp => resp.json().then(data => ({ ok: resp.ok, data })).catch(() => ({ ok: resp.ok, data: {} })))
            .then(({ ok, data }) => {
              if (!ok) {
                throw new Error(data.error || 'Error eliminando fase archivada');
              }
              const targetPid = removeArchivedBtn.dataset.pid;
              const targetPhase = removeArchivedBtn.dataset.phase;
              const affectedCells = new Set();
              document.querySelectorAll('.task').forEach(taskEl => {
                if (taskEl.dataset.pid === targetPid && taskEl.dataset.phase === targetPhase && taskEl.dataset.archived === 'true') {
                  const row = taskEl.closest('tr[data-worker]');
                  const worker = row ? row.dataset.worker : null;
                  const date = taskEl.dataset.day || null;
                  taskEl.remove();
                  if (worker && date) {
                    affectedCells.add(`${worker}|||${date}`);
                  }
                }
              });
              affectedCells.forEach(key => {
                const [worker, date] = key.split('|||');
                recomputeWorkerDayCell(worker, date);
              });
              const projectInfo = PROJECT_DATA[targetPid];
              if (projectInfo && typeof projectInfo === 'object') {
                if (projectInfo.phases && Object.prototype.hasOwnProperty.call(projectInfo.phases, targetPhase)) {
                  delete projectInfo.phases[targetPhase];
                }
                if (projectInfo.assigned && Object.prototype.hasOwnProperty.call(projectInfo.assigned, targetPhase)) {
                  delete projectInfo.assigned[targetPhase];
                }
                if (projectInfo.auto_hours && Object.prototype.hasOwnProperty.call(projectInfo.auto_hours, targetPhase)) {
                  delete projectInfo.auto_hours[targetPhase];
                }
                if (Array.isArray(projectInfo.phase_sequence)) {
                  projectInfo.phase_sequence = projectInfo.phase_sequence.filter(item => item !== targetPhase);
                }
                if (Array.isArray(projectInfo.frozen_tasks)) {
                  projectInfo.frozen_tasks = projectInfo.frozen_tasks.filter(item => item && item.phase !== targetPhase);
                }
                if (Array.isArray(projectInfo.frozen_phases)) {
                  projectInfo.frozen_phases = projectInfo.frozen_phases.filter(ph => ph !== targetPhase);
                }
              }
              popup.style.display = 'none';
            })
            .catch(err => {
              alert(err.message || 'Error eliminando fase archivada');
            });
        });
      }
      const del = document.getElementById('del-btn');
      if (del) {
        del.addEventListener('click', ev => {
          ev.stopPropagation();
          if (confirm('¿Borrar fase?')) {
            fetch(DELETE_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ pid: del.dataset.pid, phase: del.dataset.phase })
            }).then(() => location.reload());
          }
        });
      }
      const unplan = document.getElementById('unplan-btn');
      if (unplan) {
        unplan.addEventListener('click', ev => {
          ev.stopPropagation();
          const today = madridDateISO();
          const body = { pid: unplan.dataset.pid, phase: unplan.dataset.phase, date: today, worker: 'Sin planificar' };
          const partValue = normalizePartValue(unplan.dataset.part);
          if (partValue) body.part = partValue;
          fetch(MOVE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          })
            .then(resp => resp.json().then(d => ({ ok: resp.ok, data: d })))
            .then(({ ok, data }) => {
              if (!ok) {
                alert(data.error || 'Error');
                return;
              }
              afterMove(data, today);
            });
        });
      }
      const obsSave = document.getElementById('obs-save');
      const obsText = document.getElementById('obs-text');
      if (obsSave && obsText) {
        obsSave.addEventListener('click', ev => {
          ev.stopPropagation();
          const pid = obsSave.dataset.pid;
          const txt = obsText.value;
          const url = OBS_URL_TEMPLATE.replace('__PID__', encodeURIComponent(pid));
          const originalLabel = obsSave.textContent;
          obsSave.disabled = true;
          obsSave.textContent = 'Guardando...';
          fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ observations: txt })
          })
            .then(resp => {
              if (resp.ok) {
                return resp.text().catch(() => '');
              }
              return resp.json().catch(() => ({})).then(data => {
                throw new Error(data.error || 'Error guardando observaciones');
              });
            })
            .then(() => {
              if (PROJECT_DATA[pid]) PROJECT_DATA[pid].observations = txt;
              obsSave.textContent = 'Guardado';
              setTimeout(() => { obsSave.textContent = originalLabel; }, 1500);
            })
            .catch(err => {
              alert(err.message || 'Error guardando observaciones');
              obsSave.textContent = originalLabel;
            })
            .finally(() => {
              obsSave.disabled = false;
            });
        });
      }
      const split = document.getElementById('split-btn');
      if (split) {
        split.addEventListener('click', ev => {
          ev.stopPropagation();
          splitModal.dataset.pid = split.dataset.pid;
          splitModal.dataset.phase = split.dataset.phase;
          splitModal.dataset.date = split.dataset.date;
          prepareSplitModal(split);
          splitModal.style.display = 'block';
        });
      }
      const unsplit = document.getElementById('unsplit-btn');
      if (unsplit) {
        unsplit.addEventListener('click', ev => {
          ev.stopPropagation();
          if (confirm('¿Deshacer divisi\u00f3n de esta fase?')) {
            fetch(UNSPLIT_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ pid: unsplit.dataset.pid, phase: unsplit.dataset.phase })
            }).then(resp => { if (resp.ok) location.reload(); else resp.json().then(d => alert(d.error || 'Error')); });
          }
        });
      }
      if (splitForm && !splitForm.dataset.enhanced) {
        splitForm.addEventListener('submit', ev => {
          ev.preventDefault();
          ev.stopPropagation();
          if (!splitModal) return;
          const manuals = getSplitManualInputs();
          if (!manuals.length) {
            alert('Debes indicar al menos una parte.');
            return;
          }
          const parts = [];
          let invalid = false;
          manuals.forEach(input => {
            const value = parseSplitHours(input.value);
            if (!Number.isInteger(value) || value <= 0) {
              input.classList.add('split-input-error');
              invalid = true;
              return;
            }
            parts.push(value);
          });
          const remainderValue = splitRemainderInput ? parseSplitHours(splitRemainderInput.value) : null;
          const total = parseSplitHours(splitModal.dataset.totalHours);
          let remainderInt = null;
          if (!Number.isInteger(remainderValue) || remainderValue === null || remainderValue <= 0) {
            invalid = true;
          } else {
            remainderInt = remainderValue;
            parts.push(remainderInt);
          }
          const sumParts = parts.reduce((acc, value) => acc + value, 0);
          if (total !== null && Number.isFinite(total) && sumParts !== total) {
            invalid = true;
          }
          if (invalid) {
            alert('Revisa las horas de cada parte. Deben ser enteros positivos y sumar el total de la fase.');
            updateSplitModalDisplay();
            return;
          }
          const payload = {
            pid: splitModal.dataset.pid,
            phase: splitModal.dataset.phase,
            date: splitModal.dataset.date,
            parts,
          };
          fetch(SPLIT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload)
          }).then(resp => { if (resp.ok) location.reload(); else resp.json().then(d => alert(d.error || 'Error')); });
        });
        splitForm.dataset.enhanced = 'true';
      }
      if (splitAddPartButton && !splitAddPartButton.dataset.bound) {
        splitAddPartButton.addEventListener('click', ev => {
          ev.preventDefault();
          ev.stopPropagation();
          const remainderRow = splitRemainderInput ? splitRemainderInput.closest('.split-part-row') : null;
          const input = createSplitPartRow(null, remainderRow);
          ensureSplitRemainderInput();
          updateSplitModalDisplay();
          if (input) {
            input.focus();
          }
        });
        splitAddPartButton.dataset.bound = 'true';
      }
      if (splitCancel) {
        splitCancel.addEventListener('click', () => { splitModal.style.display = 'none'; });
      }
      const freeze = document.getElementById('freeze-btn');
      if (freeze) {
        freeze.addEventListener('click', ev => {
          ev.stopPropagation();
          fetch('/toggle_freeze/' + freeze.dataset.pid + '/' + encodeURIComponent(freeze.dataset.phase), {
            method: 'POST',
            credentials: 'same-origin'
          }).then(() => location.reload());
        });
      }
      const startForm = document.getElementById('start-form');
      if (startForm) {
        startForm.addEventListener('submit', ev => {
          ev.preventDefault();
          ev.stopPropagation();
          const btn = document.getElementById('start-btn');
          const val = document.getElementById('start-input').value;
          fetch(START_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ pid: btn.dataset.pid, phase: btn.dataset.phase, date: val })
          }).then(resp => {
            if (resp.ok) {
              // previously warned when scheduling before material confirmation, now proceed silently
              location.reload();
            } else {
              resp.json().then(d => alert(d.error || 'Error'));
            }
          });
        });
      }
      const hoursForm = document.getElementById('phase-hours-form');
      if (hoursForm) {
        hoursForm.addEventListener('submit', ev => {
          ev.preventDefault();
          ev.stopPropagation();
          const btn = hoursForm.querySelector('button');
          const val = document.getElementById('phase-hours-input').value;
          const payload = { pid: btn.dataset.pid, phase: btn.dataset.phase, hours: val };
          const partValue = normalizePartValue(btn.dataset.part);
          if (partValue) {
            payload.part = partValue;
          }
          fetch(PHASE_HOURS_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload)
          }).then(resp => { if (resp.ok) { location.reload(); } else { resp.json().then(d => alert(d.error || 'Error')); } });
        });
      }
    });
  });
  const rows = document.querySelectorAll('.projects-table tbody tr[data-pid]');
  rows.forEach(row => {
    row.addEventListener('click', e => {
      e.stopPropagation();
      const pid = row.dataset.pid;
      rows.forEach(r => {
        if (r.dataset.pid === pid) {
          r.classList.add('proj-highlight');
          r.classList.remove('proj-dim');
        } else {
          r.classList.add('proj-dim');
          r.classList.remove('proj-highlight');
        }
      });
      tasks.forEach(t => {
        if (t.dataset.pid === pid) {
          t.classList.add('highlight');
          t.classList.remove('dim');
        } else {
          t.classList.add('dim');
          t.classList.remove('highlight');
        }
      });
      folders.forEach(f => {
        if (f.dataset.pid === pid) {
          f.classList.remove('dim');
        } else {
          f.classList.add('dim');
        }
      });
    });
  });
  document.querySelectorAll('.row-update-btn').forEach(btn => {
    btn.addEventListener('click', ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const row = btn.closest('tr');
      const pid = row.dataset.pid;
      const data = {pid, phases:{}};
      row.querySelectorAll('form:not(.delete-form):not(.image-form)').forEach(f => {
        const fd = new FormData(f);
        if (f.classList.contains('phase-hours-form')) {
          data.phases[fd.get('phase')] = fd.get('hours');
        } else if (f.classList.contains('proj-start-form')) {
          data.start_date = fd.get('start_date') || fd.get('date');
        }
      });
      const imgForm = row.querySelector('.image-form');
      let imgPromise = Promise.resolve();
      if (imgForm) {
        const inp = imgForm.querySelector('input[type=file]');
        if (inp && inp.files.length) {
          const fd = new FormData(imgForm);
          imgPromise = fetch(imgForm.action, {
            method: 'POST',
            body: fd,
            credentials: 'same-origin'
          });
        }
      }
      fetch(ROW_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify(data)
      }).then(resp => {
        if (resp.ok) {
          imgPromise.then(() => {
            const url = new URL(location);
            url.searchParams.set('highlight', pid);
            location.href = url;
          });
        } else {
          resp.json().then(d => alert(d.error || 'Error'));
        }
      });
    });
  });

  document.addEventListener('click', () => {
    tasks.forEach(o => o.classList.remove('highlight', 'dim'));
    folders.forEach(f => f.classList.remove('dim'));
    rows.forEach(r => {
      r.classList.remove('proj-highlight', 'proj-dim');
    });
    popup.style.display = 'none';
  });
  popup.addEventListener('click', (e) => e.stopPropagation());
  function showTask(t) {
    t.dispatchEvent(new Event('click'));
    const rect = t.getBoundingClientRect();
    const wrapperRect = wrapper.getBoundingClientRect();
    wrapper.scrollLeft += rect.left - wrapperRect.left - wrapper.clientWidth / 2;
    t.scrollIntoView({behavior: 'smooth', block: 'center'});
  }

  const params = new URLSearchParams(location.search);
  const highlight = params.get('highlight');
  if (highlight) {
    sessionStorage.setItem('highlightPid', highlight);
    params.delete('highlight');
    const url = new URL(location);
    url.search = params.toString();
    history.replaceState(null, '', url);
  }
  const stored = sessionStorage.getItem('highlightPid');
  if (stored) {
    const t = Array.from(tasks).find(o => o.dataset.pid === stored);
    if (t) {
      showTask(t);
    } else {
      const row = Array.from(rows).find(r => r.dataset.pid === stored);
      if (row) {
        row.dispatchEvent(new Event('click'));
      } else {
        const folder = Array.from(folders).find(f => f.dataset.pid === stored);
        if (folder) {
          folders.forEach(f => {
            if (f === folder) f.classList.remove('dim');
            else f.classList.add('dim');
          });
        } else {
          folders.forEach(f => f.classList.add('dim'));
        }
      }
    }
    sessionStorage.removeItem('highlightPid');
  }

  const moved = localStorage.getItem(LAST_KEY);
  if (moved) {
    const m = JSON.parse(moved);
    tasks.forEach(t => {
      if (t.dataset.pid === m.pid && t.dataset.phase === m.phase) {
        t.classList.add('moved');
      }
    });
    const sd = localStorage.getItem(SCROLL_KEY2);
    if (sd) {
      const cell = document.querySelector(`td[data-date='${sd}']`);
      if (cell) cell.scrollIntoView({behavior:'auto', inline:'center'});
      localStorage.removeItem(SCROLL_KEY2);
    }
  }

  document.addEventListener('keydown', e => {
    if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
      const info = sessionStorage.getItem('undoMove');
      if (info) {
        const req = JSON.parse(info);
        fetch(MOVE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify({ pid: req.pid, phase: req.phase, date: req.date, worker: req.worker })
        })
          .then(resp => resp.json().then(d => ({ ok: resp.ok, data: d })))
          .then(({ ok, data }) => {
            if (!ok) {
              alert(data.error || 'Error');
              return;
            }
            sessionStorage.removeItem('undoMove');
            afterMove(data, req.date);
          });
      }
    }
  });

  document.querySelectorAll('.conflict-link').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const pid = link.dataset.pid;
      const proj = link.dataset.project;
      let t = null;
      if (pid) {
        t = Array.from(tasks).find(o => o.dataset.pid === pid);
      } else {
        t = Array.from(tasks).find(o => o.dataset.project === proj);
      }
      if (t) {
        showTask(t);
      }
    });
  });
  document.querySelectorAll('.affected-link').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const pid = link.dataset.pid;
      let t = Array.from(tasks).find(o => o.dataset.pid === pid);
      if (t) {
        showTask(t);
      }
    });
  });

  function getStartHour(cell, y) {
    let hours = 0;
    const tasks = Array.from(cell.querySelectorAll('.task'));
    for (const t of tasks) {
      const currentPart = normalizePartValue(t.dataset.part);
      const draggingPart = dragInfo ? normalizePartValue(dragInfo.part) : '';
      if (dragInfo && t.dataset.pid === dragInfo.pid && t.dataset.phase === dragInfo.phase && currentPart === draggingPart) continue;
      const rect = t.getBoundingClientRect();
      if (y < rect.top + rect.height / 2) break;
      hours += parseFloat(t.dataset.hours || '0');
    }
    return hours;
  }
  document.querySelectorAll('tbody td[data-date]').forEach(cell => {
    cell.addEventListener('dragover', e => { e.preventDefault(); });
    cell.addEventListener('drop', e => {
      e.preventDefault();
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      const date = cell.dataset.date;
      const worker = cell.closest('tr').dataset.worker;
      const info = PROJECT_DATA[data.pid] || {};
      const beforeMaterial = info.material_confirmed_date && date < info.material_confirmed_date;
      if (lastDrag) {
        sessionStorage.setItem('undoMove', JSON.stringify(lastDrag));
      }
      const start = getStartHour(cell, e.clientY);
      const moveData = { pid: data.pid, phase: data.phase, date: date, worker: worker, part: data.part, start: start };
      doMove(moveData, 'split', beforeMaterial);
    });
  });
  function doMove(moveData, mode, beforeMaterial) {
    moveData.mode = mode;
    fetch(MOVE_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(moveData)
    })
    .then(resp => resp.json().then(j => ({ok: resp.ok, data: j})))
    .then(({ok, data}) => {
      if (!ok) {
        if (data.blocked) {
          pendingBlock = { moveData, mode, beforeMaterial };
          blockText.textContent = `Hay una fase bloqueada (${data.blocked.name} - ${data.blocked.phase}). ¿Quieres descongelar la fase y que se aplace con el resto o que se atrase lo demás saltándose esa fase?`;
          blockModal.style.display = 'block';
          return;
        }
        alert(data.error || 'Error');
        return;
      }
      afterMove(data, moveData.date);
    });
  }
  if (blockUnfreeze) {
    blockUnfreeze.addEventListener('click', () => {
      if (pendingBlock) {
        blockModal.style.display = 'none';
        pendingBlock.moveData.unblock = true;
        doMove(pendingBlock.moveData, pendingBlock.mode, pendingBlock.beforeMaterial);
        pendingBlock = null;
      }
    });
  }
  if (blockSkip) {
    blockSkip.addEventListener('click', () => {
      if (pendingBlock) {
        blockModal.style.display = 'none';
        pendingBlock.moveData.skip_block = true;
        doMove(pendingBlock.moveData, pendingBlock.mode, pendingBlock.beforeMaterial);
        pendingBlock = null;
      }
    });
  }
  if (blockCancel) {
    blockCancel.addEventListener('click', () => {
      blockModal.style.display = 'none';
      pendingBlock = null;
    });
  }
  document.querySelectorAll('.unplanned-list').forEach((list) => {
    list.addEventListener('dragover', (e) => { e.preventDefault(); });
    list.addEventListener('drop', (e) => {
      e.preventDefault();
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      const today = madridDateISO();
      if (lastDrag) {
        sessionStorage.setItem('undoMove', JSON.stringify(lastDrag));
      }
      fetch(MOVE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ pid: data.pid, phase: data.phase, date: today, worker: 'Sin planificar', part: data.part })
      })
        .then(resp => resp.json().then(d => ({ ok: resp.ok, data: d })))
        .then(({ ok, data }) => {
          if (!ok) {
            alert(data.error || 'Error');
            return;
          }
          afterMove(data, today);
        });
    });
  });

  const manualZone = document.getElementById('manual-dropzone');

  function manualDropIndex(zone, clientY) {
    if (!zone) return 0;
    const items = Array.from(zone.querySelectorAll('.manual-task'));
    const filtered = draggedTaskElement ? items.filter(el => el !== draggedTaskElement) : items;
    let index = filtered.length;
    for (let i = 0; i < filtered.length; i += 1) {
      const rect = filtered[i].getBoundingClientRect();
      if (clientY < rect.top + rect.height / 2) {
        index = i;
        break;
      }
    }
    return index;
  }

  function refreshManualPlaceholder() {
    if (!manualZone) return;
    const placeholder = manualZone.querySelector('.manual-placeholder');
    if (!placeholder) return;
    const hasTask = manualZone.querySelector('.manual-task');
    placeholder.style.display = hasTask ? 'none' : 'block';
  }

  function persistManualOrder() {
    if (!manualZone) return;
    const order = Array.from(manualZone.querySelectorAll('.manual-task')).map((el) => {
      const rawPart = normalizePartValue(el.dataset.part);
      let part = null;
      if (rawPart) {
        const num = Number(rawPart);
        part = Number.isFinite(num) ? num : null;
      }
      return {
        pid: el.dataset.pid,
        phase: el.dataset.phase,
        part,
      };
    });
    fetch(MANUAL_REORDER_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({ order }),
    })
      .then((resp) => {
        if (!resp.ok) {
          return resp
            .json()
            .catch(() => ({}))
            .then((d) => {
              throw new Error(d.error || 'Error');
            });
        }
        return null;
      })
      .catch((err) => {
        alert(err.message || 'Error');
      });
  }

  refreshManualPlaceholder();

  if (manualZone) {
    manualZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      manualZone.classList.add('drag-over');
    });
    manualZone.addEventListener('dragleave', (e) => {
      if (e.target === manualZone || !manualZone.contains(e.relatedTarget)) {
        manualZone.classList.remove('drag-over');
      }
    });
    manualZone.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      manualZone.classList.remove('drag-over');
      let data = null;
      try {
        data = JSON.parse(e.dataTransfer.getData('text/plain'));
      } catch (err) {
        data = null;
      }
      if (!data) return;
      const index = manualDropIndex(manualZone, e.clientY);
      if (dragInfo && dragInfo.manual) {
        const el = draggedTaskElement;
        if (el) {
          const siblings = Array.from(manualZone.querySelectorAll('.manual-task')).filter((item) => item !== el);
          if (index >= siblings.length) {
            manualZone.appendChild(el);
          } else {
            manualZone.insertBefore(el, siblings[index]);
          }
          persistManualOrder();
          refreshManualPlaceholder();
        }
        return;
      }
      const today = madridDateISO();
      if (lastDrag) {
        sessionStorage.setItem('undoMove', JSON.stringify(lastDrag));
      }
      const payload = {
        pid: data.pid,
        phase: data.phase,
        date: today,
        worker: 'Sin planificar',
        part: data.part,
        manual_bucket: true,
        manual_position: index,
      };
      const placeholder = manualZone.querySelector('.manual-placeholder');
      if (placeholder) placeholder.style.display = 'none';
      fetch(MOVE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify(payload),
      })
        .then((resp) => resp.json().then((d) => ({ ok: resp.ok, data: d })))
        .then(({ ok, data: moveData }) => {
          if (!ok) {
            alert(moveData.error || 'Error');
            return;
          }
          afterMove(moveData, today);
        });
    });
  }
  const unplanPanel = document.getElementById('unplanned-panel');
  const unplanResizer = document.getElementById('unplanned-resizer');
  const UNPLAN_WIDTH_KEY = 'unplannedWidth';

  function syncUnplannedHeight() {
    const wrap = document.querySelector('.schedule-wrapper');
    if (wrap && unplanPanel) {
      unplanPanel.style.height = wrap.offsetHeight + 'px';
    }
  }

  syncUnplannedHeight();
  window.addEventListener('resize', syncUnplannedHeight);
  if (unplanPanel) {
    const savedWidth = localStorage.getItem(UNPLAN_WIDTH_KEY);
    if (savedWidth) {
      unplanPanel.style.width = savedWidth + 'px';
    }
  }
  if (unplanPanel && unplanResizer) {
    let startX, startWidth;
    const onMouseMove = (e) => {
      const dx = startX - e.clientX;
      const newWidth = Math.max(100, startWidth + dx);
      unplanPanel.style.width = newWidth + 'px';
    };
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      localStorage.setItem(UNPLAN_WIDTH_KEY, unplanPanel.offsetWidth);
    };
    unplanResizer.addEventListener('mousedown', (e) => {
      startX = e.clientX;
      startWidth = unplanPanel.offsetWidth;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }
  document.querySelectorAll('.task.vacation').forEach(div => {
    div.addEventListener('click', () => {
      const del = div.querySelector('.vac-delete');
      if (del) del.style.display = 'block';
    });
  });
  document.querySelectorAll('.vac-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const parent = btn.parentElement;
      const worker = parent.dataset.worker;
      const day = parent.dataset.day;
      fetch('/remove_vacation', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: `worker=${encodeURIComponent(worker)}&date=${encodeURIComponent(day)}`
      }).then(() => location.reload());
    });
  });
  document.querySelectorAll('.folder-toggle').forEach(btn => {
    btn.addEventListener('click', () => {
      const content = btn.parentElement.nextElementSibling;
      const hidden = content.style.display === 'none';
      content.style.display = hidden ? 'block' : 'none';
      btn.innerHTML = hidden ? '&#8722;' : '&#43;';
    });
  });
  const projToggle = document.getElementById('projects-toggle');
  if (projToggle) {
    const projDiv = document.querySelector('.complete-projects');
    projToggle.addEventListener('click', () => {
      projDiv.classList.toggle('collapsed');
      projToggle.innerHTML = projDiv.classList.contains('collapsed') ? '&#43;' : '&#8722;';
    });
  }
  document.querySelectorAll('.proj-start-form').forEach(f => {
    f.addEventListener('submit', ev => {
      ev.preventDefault();
      const data = new FormData(f);
      fetch(PROJ_START_URL, { method: 'POST', body: data, credentials: 'same-origin' })
        .then(resp => {
          if (resp.ok) { location.reload(); } else { resp.json().then(d => alert(d.error || 'Error')); }
        });
    });
  });
  document.querySelectorAll('.phase-hours-form').forEach(f => {
    f.addEventListener('submit', ev => {
      ev.preventDefault();
      const data = new FormData(f);
      fetch(PHASE_HOURS_URL, { method: 'POST', body: data, credentials: 'same-origin' })
        .then(resp => {
          if (resp.ok) {
            const url = new URL(location);
            url.searchParams.set('highlight', data.get('pid'));
            location.href = url;
          } else {
            resp.json().then(d => alert(d.error || 'Error'));
          }
        });
    });
  });

  // Save image immediately when selected
  document.querySelectorAll('.image-form input[type=file]').forEach(inp => {
    inp.addEventListener('change', () => {
      const form = inp.closest('form');
      const fd = new FormData(form);
      fetch(form.action, {
        method: 'POST',
        body: fd,
        credentials: 'same-origin'
      }).then(resp => {
        if (resp.ok) {
          location.reload();
        } else {
          resp.json().then(d => alert(d.error || 'Error'));
        }
      });
    });
  });
  const CONFLICTS = {{ conflicts|tojson }};
  const conflictModal = document.getElementById("conflict-modal");
  const conflictText = document.getElementById("conflict-text");
  const conflictClose = document.getElementById("conflict-close");
  const seen = JSON.parse(localStorage.getItem('seenConflicts') || '{}');
  const NEW_CONFLICTS = CONFLICTS.filter(
    c => !seen[c.key]
  );
  let conflictIndex = 0;
  function showNextConflict() {
    if (conflictIndex < NEW_CONFLICTS.length) {
      const c = NEW_CONFLICTS[conflictIndex];
      conflictText.textContent = c.project + " - " + (c.client || '') + ": " + c.message;
      conflictModal.style.display = "block";
    } else {
      conflictModal.style.display = "none";
    }
  }
  if (NEW_CONFLICTS.length) {
    showNextConflict();
    conflictClose.addEventListener("click", () => {
      const c = NEW_CONFLICTS[conflictIndex];
      seen[c.key] = true;
      localStorage.setItem('seenConflicts', JSON.stringify(seen));
      conflictIndex++;
      showNextConflict();
    });
  }

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      if (conflictModal && conflictClose && conflictModal.style.display === 'block') conflictClose.click();
      if (splitModal && splitModal.style.display === 'block') splitCancel.click();
      if (blockModal && blockModal.style.display === 'block') blockCancel.click();
    }
  });
  });
</script>
{% endblock %}
