{% extends 'base.html' %}
{% block content %}
<form id="quick-card-form" class="quick-card-form">
  <label class="quick-card-field" for="quick-card-date">
    <span>Fecha</span>
    <input type="date" id="quick-card-date" name="date" required>
  </label>
  <label class="quick-card-field" for="quick-card-title">
    <span>Título</span>
    <input type="text" id="quick-card-title" name="title" placeholder="Título del pedido" required>
  </label>
  <button type="submit">Crear tarjeta</button>
</form>
<input type="text" id="filter-input" placeholder="Filtrar por título o cliente">
{% set calendar_definitions = [
  {'key': 'pedidos', 'title': 'Calendario pedidos', 'weeks': weeks, 'unconfirmed': unconfirmed},
  {'key': 'subcontrataciones', 'title': 'Calendario subcontrataciones', 'weeks': subcontr_weeks, 'unconfirmed': subcontr_unconfirmed}
] %}
<div class="pedidos-wrapper">
  <div class="pedidos-calendar-stack">
  {% for calendar in calendar_definitions %}
    <h2>{{ calendar.title }}</h2>
    {% set week_count = calendar.weeks|length %}
    {% if week_count < 1 %}
      {% set week_count = 1 %}
    {% endif %}
    <div class="pedidos-calendar-container" data-calendar="{{ calendar.key }}">
      <table class="pedidos-calendar" data-calendar="{{ calendar.key }}">
        <thead>
        <tr>
            <th class="week-header">Semana</th>
            <th class="day-header">Lun</th>
            <th class="day-header">Mar</th>
            <th class="day-header">Mié</th>
            <th class="day-header">Jue</th>
            <th class="day-header">Vie</th>
            <th rowspan="{{ week_count + 1 }}" class="unconfirmed-header">Sin fecha de entrega confirmada</th>
        </tr>
        </thead>
        <tbody>
        {% for week in calendar.weeks %}
        <tr>
            <td class="week-label">Semana {{ week.number }}</td>
            {% for d in week.days %}
            <td data-date="{{ d.date.isoformat() }}" class="day-cell{% if d.date == today %} today{% endif %}">
                {% if d.month %}<div class="month-divider">{{ d.month }}</div>{% endif %}
                <div class="day-number">{{ d.day }}</div>
                {% for t in d.tasks %}
                <div class="task{% if t.get('simulated') %} simulated{% endif %}" draggable="true"
                     data-pid="{{ t.get('pid') or '' }}"
                     data-phase="{{ t.get('phase') or '' }}"
                     data-day="{{ d.date.isoformat() }}"
                     data-worker="{{ t.get('worker') or '' }}"
                     data-cid="{{ t.get('cid') or '' }}"
                     data-project="{{ t.project }}"
                     data-title="{{ t.project }}"
                     data-code="{{ t.get('custom_card_id') or '' }}"
                     data-client="{{ t.get('client') or '' }}"
                     data-due="{{ d.date.isoformat() }}"
                     data-lane="{{ t.get('lane') or '' }}"
                     {% if t.get('part') is not none %}data-part="{{ t.get('part') }}"{% endif %}
                     style="border-color: {{ t.get('color', '#999999') }};">
                    <span class="task-main">{{ t.project }}</span>
                    {% if t.hours %}
                    <span class="task-hours">{% if t.auto %}<span class="auto-hour">{{ t.hours }}h</span>{% else %}{{ t.hours }}h{% endif %}</span>
                    {% endif %}
                </div>
                {% endfor %}
            </td>
            {% endfor %}
            {% if loop.first %}
            <td class="unconfirmed" rowspan="{{ week_count }}">
                {% for t in calendar.unconfirmed %}
                  <div class="task{% if t.get('simulated') %} simulated{% endif %}" draggable="true"
                       data-pid="{{ t.get('pid') or '' }}"
                       data-phase="{{ t.get('phase') or '' }}"
                       data-worker="{{ t.get('worker') or '' }}"
                       data-cid="{{ t.get('cid') or '' }}"
                       data-project="{{ t.project }}"
                       data-title="{{ t.project }}"
                       data-code="{{ t.get('custom_card_id') or '' }}"
                       data-client="{{ t.get('client') or '' }}"
                       data-lane="{{ t.get('lane') or '' }}"
                       style="border-color: {{ t.get('color', '#999999') }};">
                    <span class="task-main">{{ t.project }}</span>
                    {% if t.prev_date %}<span class="task-date">({{ t.prev_date }})</span>{% endif %}
                    {% if t.hours %}<span class="task-hours">{{ t.hours }}h</span>{% endif %}
                </div>
                {% endfor %}
            </td>
            {% endif %}
        </tr>
        {% endfor %}
        </tbody>
      </table>
    </div>
  {% endfor %}
  </div>
<div class="columna-1">
    <div class="columna-1-title" id="columna-1-info-title" data-default-title="{{ project_info_title or '' }}">{{ project_info_title or '' }}</div>
    <h3>Columna 1</h3>
    <div class="columna-1-table-wrapper">
      <table class="columna-1-table">
        <colgroup>
          <col data-col-key="project" data-default-width="380">
          <col data-col-key="due" data-default-width="140">
          <col data-col-key="start" data-default-width="170">
          <col data-col-key="order-date" data-default-width="160">
          <col data-col-key="order-count" data-default-width="120">
          <col data-col-key="links" data-default-width="360">
          <col data-col-key="observations" data-default-width="320">
        </colgroup>
        <thead>
          <tr>
            <th scope="col">Proyecto</th>
            <th scope="col">Entrega (Fecha tope)</th>
            <th scope="col">Inicio planificado</th>
            <th scope="col">Fecha pedido</th>
            <th scope="col">Conteo</th>
            <th scope="col">Fases</th>
            <th scope="col" class="observations-header">Observaciones</th>
          </tr>
        </thead>
        <tbody class="columna-1-content">
        {% for item in project_links %}
            {% set project_value = (item.project or item.title)|trim %}
            {% set title_value = (item.title or item.project)|trim %}
            {% set code_value = (item.custom_card_id or '')|trim %}
            {% set plan_value = item.plan_start or item.montar_start %}
            {% set due_display = (item.due|format_due_date)|trim %}
            {% set start_display = (plan_value|format_due_date)|trim %}
            {% set details = item.link_details or [] %}
            {% set pid_value = item.pid|string if item.pid is not none else '' %}
            {% set project_entry = project_data.get(pid_value) or project_data.get(item.pid) %}
            {% set obs_value = project_entry.observations if project_entry and project_entry.observations is not none else '' %}
          <tr class="project-row"
              data-pid="{{ item.pid or '' }}"
              data-project="{{ project_value }}"
              data-title="{{ title_value }}"
              data-display="{{ (item.display_title or item.title or item.project)|trim }}"
              data-client="{{ item.client }}"
              data-code="{{ code_value }}"
              data-due="{{ item.due or '' }}"
              data-plan="{{ plan_value or '' }}">
            <td class="proj-title-cell" data-sort="{{ (title_value or project_value)|default('', true)|lower }}">
              {% if code_value %}
              <span class="proj-code proj-code-badge"
                    data-project="{{ project_value }}"
                    data-code="{{ code_value }}">{{ code_value }}</span>
              {% endif %}
              <strong class="proj-title"
                      data-project="{{ project_value }}"
                      data-code="{{ code_value }}">{{ title_value or project_value }}</strong>
            </td>
            <td class="due-cell" data-sort="{{ item.due or '' }}" data-sort-type="date">
            {% if due_display %}
              <span class="proj-due">{{ due_display }}</span>
            {% endif %}
            </td>
            <td class="start-cell" data-sort="{{ plan_value or '' }}" data-sort-type="date">
            {% if start_display %}
              <span class="proj-start">{{ start_display }}</span>
            {% endif %}
            </td>
            {% set order_meta = namespace(first=None) %}
            {% set count_meta = namespace(value=None) %}
            {% set link_meta = namespace(value=None) %}
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set order_value = detail.order_date %}
                {% if order_value %}
                    {% if order_meta.first is none or order_value < order_meta.first %}
                        {% set order_meta.first = order_value %}
                    {% endif %}
                {% endif %}
                {% set order_days = detail.order_days %}
                {% if order_days is not none and count_meta.value is none %}
                    {% set count_meta.value = order_days %}
                {% endif %}
                {% if link_meta.value is none and link %}
                    {% set link_meta.value = link|lower %}
                {% endif %}
            {% endfor %}
            <td class="order-date-cell" data-sort="{{ order_meta.first or '' }}" data-sort-type="date">
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set order_value = detail.order_date %}
                {% set order_raw = detail.order_date_raw %}
              <div class="order-date-entry"
                   {% if order_value %}data-order="{{ order_value }}"{% endif %}>
                {% if order_value %}
                  {{ order_value|format_due_date }}
                {% elif order_raw %}
                  {{ order_raw }}
                {% else %}
                  &nbsp;
                {% endif %}
              </div>
            {% endfor %}
            </td>
            <td class="order-count-cell" data-sort="{{ count_meta.value if count_meta.value is not none else '' }}" data-sort-type="number">
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set order_days = detail.order_days %}
              <div class="order-count-entry"
                   {% if order_days is not none %}data-days="{{ order_days }}"{% endif %}>
                {% if order_days is not none %}
                  {{ order_days }}
                {% else %}
                  &nbsp;
                {% endif %}
              </div>
            {% endfor %}
            </td>
            <td class="links-cell" data-sort="{{ link_meta.value or '' }}">
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set column_value = detail.column|default('', true) %}
                {% set lane_value = detail.lane|default('', true) %}
                {% set tooltip = column_value %}
                {% if not tooltip and lane_value %}
                  {% set tooltip = lane_value %}
                {% elif tooltip and lane_value and lane_value != column_value %}
                  {% set tooltip = tooltip ~ ' · ' ~ lane_value %}
                {% endif %}
              <div class="link-title"
                   data-title="{{ link }}"
                   data-lane="{{ lane_value }}"
                   data-column="{{ column_value }}"
                   {% if tooltip %}title="{{ tooltip }}"{% endif %}>{{ link }}</div>
            {% endfor %}
            </td>
            <td class="observations-cell" data-sort="{{ obs_value|lower }}">
              {% if pid_value %}
              <textarea class="observations-input" data-pid="{{ pid_value }}" placeholder="Añade observaciones">{{ obs_value }}</textarea>
              <div class="observations-status" aria-live="polite"></div>
              {% else %}
              <textarea class="observations-input" disabled placeholder="Sin proyecto vinculado"></textarea>
              <div class="observations-status" aria-live="polite"></div>
              {% endif %}
            </td>
          </tr>
        {% endfor %}
        </tbody>
      </table>
    </div>
</div>
</div>
<div id="info-popup" class="info-popup"></div>
<div id="split-modal" class="conflict-modal">
  <div class="conflict-content">
    <form id="split-form">
      <div id="split-total-hours" class="split-total-hours"></div>
      <div id="split-parts-container" class="split-parts-container"></div>
      <button type="button" id="split-add-part" class="split-add-part" title="Añadir parte">+</button>
      <div class="split-actions">
        <button type="submit">Aceptar</button>
        <button type="button" id="split-cancel">Cancelar</button>
      </div>
    </form>
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const PROJECT_DATA = {{ project_data|tojson }};
  const START_DATA = {{ start_map|tojson }};
  const PHASES = {{ phases|tojson }};
  const STATIC_URL = "{{ url_for('static', filename='') }}";
  const MOVE_URL = "{{ url_for('move_phase') }}";
  const DELETE_URL = "{{ url_for('delete_phase') }}";
  const START_URL = "{{ url_for('update_phase_start') }}";
  const SPLIT_URL = "{{ split_phase_url }}";
  const UNSPLIT_URL = "{{ url_for('unsplit_phase') }}";
  const TABLE_COLLATOR = typeof Intl !== 'undefined'
    ? new Intl.Collator('es', { sensitivity: 'base', numeric: true })
    : null;
  const PHASE_HOURS_URL = "{{ url_for('update_phase_hours') }}";
  const OBS_URL_TEMPLATE = "{{ url_for('update_observations', pid='__PID__') }}";
  const COMPLETE_URL = "{{ url_for('complete') }}";
  const LAST_KEY = 'lastMoved';
  const SCROLL_KEY2 = 'scrollDate';
  const COLUMN_WIDTHS_KEY = 'columna1ColumnWidths';
  const popup = document.getElementById('info-popup');
  const splitModal = document.getElementById('split-modal');
  const splitForm = document.getElementById('split-form');
  const splitPartsContainer = document.getElementById('split-parts-container');
  const splitAddPartButton = document.getElementById('split-add-part');
  const splitTotalDisplay = document.getElementById('split-total-hours');
  const splitCancel = document.getElementById('split-cancel');
  let splitRemainderInput = null;
  let startDayHighlightCell = null;
  const SPLIT_WORKDAY_HOURS = 8;
  const SPLIT_ORDINAL_WORDS = ['primera', 'segunda', 'tercera', 'cuarta', 'quinta', 'sexta', 'séptima', 'octava', 'novena', 'décima'];
  const pageParams = new URLSearchParams(window.location.search);
  const initialFilterValue = pageParams.get('filter');
  const initialHighlightPid = pageParams.get('highlight');
  const START_DAY_HIGHLIGHT_CLASS = 'start-day-highlight';
  const quickCardForm = document.getElementById('quick-card-form');
  const quickCardDate = document.getElementById('quick-card-date');
  const quickCardTitle = document.getElementById('quick-card-title');
  const QUICK_CARD_STORAGE_KEY = 'pedidosQuickCards';
  const QUICK_CARD_ORDER_STORAGE_KEY = 'pedidosQuickCardOrder';
  const FILTER_STORAGE_KEY = 'pedidosCalendarFilter';
  const UNCONFIRMED_ORDER_KEY = '__unconfirmed__';
  const quickCardStorageEnabled = (() => {
    try {
      if (typeof window === 'undefined' || !window.localStorage) {
        return false;
      }
      const probeKey = '__quickCardProbe__';
      window.localStorage.setItem(probeKey, '1');
      window.localStorage.removeItem(probeKey);
      return true;
    } catch (error) {
      return false;
    }
  })();
  let quickCardStore = [];
  let taskOrderMap = {};

  function loadTaskOrderFromStorage() {
    if (!quickCardStorageEnabled) {
      return {};
    }
    try {
      const raw = window.localStorage.getItem(QUICK_CARD_ORDER_STORAGE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return {};
      return Object.keys(parsed).reduce((acc, key) => {
        const value = parsed[key];
        if (Array.isArray(value)) {
          acc[key] = value.filter(id => typeof id === 'string' && id);
        }
        return acc;
      }, {});
    } catch (error) {
      return {};
    }
  }

  function persistTaskOrder() {
    if (!quickCardStorageEnabled) {
      return;
    }
    try {
      window.localStorage.setItem(QUICK_CARD_ORDER_STORAGE_KEY, JSON.stringify(taskOrderMap));
    } catch (error) {
      // Ignore persistence issues
    }
  }

  function removeTaskIdFromOrder(id) {
    if (!id) return;
    let changed = false;
    Object.keys(taskOrderMap).forEach((key) => {
      const current = taskOrderMap[key];
      if (!Array.isArray(current)) {
        return;
      }
      const filtered = current.filter(value => value !== id);
      if (filtered.length !== current.length) {
        changed = true;
        if (filtered.length) {
          taskOrderMap[key] = filtered;
        } else {
          delete taskOrderMap[key];
        }
      }
    });
    if (changed) {
      persistTaskOrder();
    }
  }

  function pruneTaskOrder(validQuickCardIds) {
    if (validQuickCardIds && !(validQuickCardIds instanceof Set)) {
      return;
    }
    let changed = false;
    Object.keys(taskOrderMap).forEach((key) => {
      const current = taskOrderMap[key];
      if (!Array.isArray(current)) {
        delete taskOrderMap[key];
        changed = true;
        return;
      }
      const filtered = current.filter(id => {
        if (!validQuickCardIds) {
          return true;
        }
        if (id.startsWith('phase:') || id.startsWith('cid:')) {
          return true;
        }
        return validQuickCardIds.has(id);
      });
      if (!filtered.length) {
        if (current.length) {
          delete taskOrderMap[key];
          changed = true;
        }
        return;
      }
      if (filtered.length !== current.length) {
        taskOrderMap[key] = filtered;
        changed = true;
      }
    });
    if (changed) {
      persistTaskOrder();
    }
  }

  function getCellStorageKey(cell) {
    if (!cell) {
      return null;
    }
    if (cell.dataset && cell.dataset.date) {
      return cell.dataset.date;
    }
    if (cell.classList && cell.classList.contains('unconfirmed')) {
      return UNCONFIRMED_ORDER_KEY;
    }
    return null;
  }

  function getTaskStorageId(element) {
    if (!element || !element.dataset) {
      return null;
    }
    if (element.dataset.quickCardId) {
      return element.dataset.quickCardId;
    }
    if (element.dataset.cid) {
      return `cid:${element.dataset.cid}`;
    }
    if (element.dataset.pid && element.dataset.phase) {
      const partValue = normalizePartValue(element.dataset.part);
      return `phase:${element.dataset.pid}:${element.dataset.phase}:${partValue}`;
    }
    return null;
  }

  function getCellTaskIds(cell) {
    if (!cell) {
      return [];
    }
    return Array.from(cell.querySelectorAll('.task')).map(getTaskStorageId).filter(Boolean);
  }

  function captureTaskOrderForCell(cell) {
    const key = getCellStorageKey(cell);
    if (!key) {
      return;
    }
    const ids = getCellTaskIds(cell);
    if (!ids.length) {
      if (taskOrderMap[key]) {
        delete taskOrderMap[key];
        persistTaskOrder();
      }
      return;
    }
    const prev = taskOrderMap[key] || [];
    const changed = prev.length !== ids.length || ids.some((value, index) => prev[index] !== value);
    if (!changed) {
      return;
    }
    taskOrderMap[key] = ids;
    persistTaskOrder();
  }

  function applyTaskOrderToCell(cell) {
    const key = getCellStorageKey(cell);
    if (!key) {
      return;
    }
    const ids = taskOrderMap[key];
    if (!Array.isArray(ids) || !ids.length) {
      return;
    }
    const tasks = Array.from(cell.querySelectorAll('.task'));
    if (!tasks.length) {
      return;
    }
    const byId = new Map();
    tasks.forEach(el => {
      const storageId = getTaskStorageId(el);
      if (storageId) {
        byId.set(storageId, el);
      }
    });
    ids.forEach(id => {
      const element = byId.get(id);
      if (element) {
        cell.appendChild(element);
        byId.delete(id);
      }
    });
    byId.forEach((element) => {
      cell.appendChild(element);
    });
    const finalIds = getCellTaskIds(cell);
    const stored = taskOrderMap[key] || [];
    const changed = finalIds.length
      ? (stored.length !== finalIds.length || finalIds.some((value, index) => stored[index] !== value))
      : stored.length > 0;
    if (changed) {
      if (finalIds.length) {
        taskOrderMap[key] = finalIds;
      } else {
        delete taskOrderMap[key];
      }
      persistTaskOrder();
    }
  }

  function applyStoredOrderToCalendar() {
    document.querySelectorAll('.pedidos-calendar td.day-cell[data-date], .pedidos-calendar td.unconfirmed').forEach(cell => {
      applyTaskOrderToCell(cell);
    });
  }

  function loadQuickCardsFromStorage() {
    if (!quickCardStorageEnabled) {
      return [];
    }
    try {
      const raw = window.localStorage.getItem(QUICK_CARD_STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed
        .map(entry => {
          if (!entry || typeof entry !== 'object') return null;
          const id = typeof entry.id === 'string' ? entry.id : null;
          const date = typeof entry.date === 'string' ? entry.date : null;
          const title = typeof entry.title === 'string' ? entry.title : null;
          if (!id || !date || !title) return null;
          return { id, date, title };
        })
        .filter(Boolean);
    } catch (error) {
      return [];
    }
  }

  function persistQuickCards() {
    if (!quickCardStorageEnabled) {
      return;
    }
    try {
      window.localStorage.setItem(QUICK_CARD_STORAGE_KEY, JSON.stringify(quickCardStore));
    } catch (error) {
      // Ignore persistence issues (e.g. quota exceeded)
    }
  }

  function updateQuickCardStoreDate(cardId, date) {
    if (!cardId) {
      return;
    }
    let changed = false;
    quickCardStore = quickCardStore.map(card => {
      if (card.id === cardId) {
        if (card.date !== date) {
          changed = true;
          return { id: card.id, date, title: card.title };
        }
      }
      return card;
    });
    if (changed) {
      persistQuickCards();
    }
  }

  function generateQuickCardId() {
    return `qc_${Date.now().toString(36)}${Math.random().toString(36).slice(2, 8)}`;
  }

  function hideAllQuickCardDeleteButtons(except = null) {
    document.querySelectorAll('.task.quick-card.quick-card-show-delete').forEach(card => {
      if (except && card === except) {
        return;
      }
      card.classList.remove('quick-card-show-delete');
    });
  }

  function removeQuickCardById(id) {
    if (!id) return;
    const nextStore = quickCardStore.filter(card => card.id !== id);
    if (nextStore.length !== quickCardStore.length) {
      quickCardStore = nextStore;
      persistQuickCards();
      removeTaskIdFromOrder(id);
    }
  }

  function createQuickCardElement(card) {
    const element = document.createElement('div');
    element.className = 'task quick-card';
    element.setAttribute('draggable', 'true');
    element.dataset.quickCardId = card.id;
    element.dataset.project = card.title;
    element.dataset.title = card.title;
    element.dataset.client = '';
    element.dataset.code = '';
    if (card.date === UNCONFIRMED_ORDER_KEY) {
      element.dataset.day = '';
      element.dataset.due = '';
    } else {
      element.dataset.day = card.date;
      element.dataset.due = card.date;
    }

    const main = document.createElement('span');
    main.className = 'task-main';
    main.textContent = card.title;
    element.appendChild(main);

    const deleteButton = document.createElement('button');
    deleteButton.type = 'button';
    deleteButton.className = 'quick-card-delete';
    deleteButton.setAttribute('aria-label', 'Eliminar tarjeta');
    deleteButton.textContent = '✖';
    deleteButton.addEventListener('click', (event) => {
      event.stopPropagation();
      const parentCell = element.closest('td.day-cell[data-date], td.unconfirmed');
      const cardId = element.dataset.quickCardId;
      element.remove();
      removeQuickCardById(cardId);
      hideAllQuickCardDeleteButtons();
      scheduleCalendarHeightRecalc();
      if (parentCell) {
        captureTaskOrderForCell(parentCell);
      }
      const filterField = document.getElementById('filter-input');
      if (filterField && filterField.value) {
        filterField.dispatchEvent(new Event('input'));
      }
    });
    element.appendChild(deleteButton);

    element.addEventListener('click', (event) => {
      if (event.target.closest('.quick-card-delete')) {
        return;
      }
      event.stopPropagation();
      hideAllQuickCardDeleteButtons(element);
      element.classList.add('quick-card-show-delete');
    });

    element.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        hideAllQuickCardDeleteButtons(element);
        element.classList.add('quick-card-show-delete');
      }
    });

    element.tabIndex = 0;

    return element;
  }

  function attachQuickCardToCalendar(card, targetCell = null, captureOrder = true) {
    let cell = targetCell;
    if (!cell) {
      if (card.date === UNCONFIRMED_ORDER_KEY) {
        cell = document.querySelector('.pedidos-calendar td.unconfirmed');
      } else if (card.date) {
        cell = document.querySelector(`.pedidos-calendar td.day-cell[data-date="${card.date}"]`);
      }
    }
    if (!cell) {
      return null;
    }
    const element = createQuickCardElement(card);
    cell.appendChild(element);
    initTaskDrag(element);
    if (captureOrder) {
      captureTaskOrderForCell(cell);
    }
    return element;
  }

  function refreshQuickCardsFromStore() {
    document.querySelectorAll('.task.quick-card[data-quick-card-id]').forEach(el => el.remove());
    quickCardStore.forEach(card => {
      attachQuickCardToCalendar(card, null, false);
    });
    const validIds = new Set(quickCardStore.map(card => card.id));
    pruneTaskOrder(validIds);
    applyStoredOrderToCalendar();
    document.querySelectorAll('.pedidos-calendar .task').forEach(initTaskDrag);
    scheduleCalendarHeightRecalc();
    const filterField = document.getElementById('filter-input');
    if (filterField && filterField.value) {
      filterField.dispatchEvent(new Event('input'));
    }
  }

  function recalcCalendarHeights() {
    const rows = document.querySelectorAll('.pedidos-calendar tbody tr');
    if (!rows.length) return;
    rows.forEach(row => {
      const rowCells = row.querySelectorAll('td.day-cell, td.week-label');
      rowCells.forEach(cell => {
        cell.style.height = '';
      });
    });
    rows.forEach(row => {
      const rowCells = row.querySelectorAll('td.day-cell, td.week-label');
      if (!rowCells.length) {
        return;
      }
      let maxHeight = 0;
      rowCells.forEach(cell => {
        if (cell.offsetHeight > maxHeight) {
          maxHeight = cell.offsetHeight;
        }
      });
      rowCells.forEach(cell => {
        cell.style.height = `${maxHeight}px`;
      });
    });
  }

  const requestHeightFrame = window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : (cb => setTimeout(cb, 16));
  const cancelHeightFrame = window.cancelAnimationFrame
    ? window.cancelAnimationFrame.bind(window)
    : clearTimeout;
  let pendingHeightFrame = null;

  function scheduleCalendarHeightRecalc() {
    if (pendingHeightFrame !== null) {
      cancelHeightFrame(pendingHeightFrame);
      pendingHeightFrame = null;
    }
    pendingHeightFrame = requestHeightFrame(() => {
      pendingHeightFrame = null;
      recalcCalendarHeights();
    });
  }

  const calendarWrapper = document.querySelector('.pedidos-calendar-container');
  const calendarBody = document.querySelector('.pedidos-calendar tbody');
  if (calendarBody) {
    const heightObserver = new MutationObserver(() => scheduleCalendarHeightRecalc());
    heightObserver.observe(calendarBody, { childList: true, subtree: true });
  }
  if (calendarWrapper && 'ResizeObserver' in window) {
    const resizeObserver = new ResizeObserver(() => scheduleCalendarHeightRecalc());
    resizeObserver.observe(calendarWrapper);
  }
  window.addEventListener('resize', scheduleCalendarHeightRecalc, { passive: true });
  window.addEventListener('orientationchange', scheduleCalendarHeightRecalc);
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(() => scheduleCalendarHeightRecalc());
  }

  if (quickCardStorageEnabled) {
    window.addEventListener('storage', (event) => {
      if (event.key === QUICK_CARD_STORAGE_KEY) {
        quickCardStore = loadQuickCardsFromStorage();
        refreshQuickCardsFromStore();
      } else if (event.key === QUICK_CARD_ORDER_STORAGE_KEY) {
        taskOrderMap = loadTaskOrderFromStorage();
        applyStoredOrderToCalendar();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!event.target.closest('.task.quick-card')) {
      hideAllQuickCardDeleteButtons();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      hideAllQuickCardDeleteButtons();
    }
  });

  taskOrderMap = loadTaskOrderFromStorage();
  quickCardStore = loadQuickCardsFromStorage();
  refreshQuickCardsFromStore();

  if (quickCardForm) {
    quickCardForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const dateValue = quickCardDate ? quickCardDate.value : '';
      const titleValue = quickCardTitle ? quickCardTitle.value.trim() : '';
      if (!dateValue || !titleValue) {
        return;
      }
      const targetCell = document.querySelector(`.pedidos-calendar td.day-cell[data-date="${dateValue}"]`);
      if (!targetCell) {
        alert('La fecha seleccionada no está visible en el calendario.');
        return;
      }
      const newCard = {
        id: generateQuickCardId(),
        date: dateValue,
        title: titleValue,
      };
      const created = attachQuickCardToCalendar(newCard, targetCell);
      if (!created) {
        alert('No se pudo crear la tarjeta en el calendario.');
        return;
      }
      quickCardStore = quickCardStore.concat([newCard]);
      persistQuickCards();
      scheduleCalendarHeightRecalc();
      const filterField = document.getElementById('filter-input');
      if (filterField && filterField.value) {
        filterField.dispatchEvent(new Event('input'));
      }
      if (quickCardForm) {
        quickCardForm.reset();
      }
      hideAllQuickCardDeleteButtons();
      created.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      if (typeof created.focus === 'function') {
        try {
          created.focus({ preventScroll: true });
        } catch (error) {
          created.focus();
        }
      }
    });
  }

  function parseSortableCell(cell) {
    if (!cell) {
      return { blank: true, value: '', type: 'text' };
    }
    const raw = cell.dataset.sort !== undefined ? cell.dataset.sort : cell.textContent.trim();
    const type = cell.dataset.sortType || 'text';
    const rawString = raw === undefined || raw === null ? '' : `${raw}`;
    const isBlank = rawString.trim() === '';
    if (type === 'number') {
      const num = Number(rawString);
      return { blank: isBlank, value: Number.isNaN(num) ? 0 : num, type };
    }
    if (type === 'date') {
      if (isBlank) {
        return { blank: true, value: 0, type };
      }
      let time = Number.NaN;
      if (/^\d{4}-\d{2}-\d{2}$/.test(rawString)) {
        time = Date.parse(rawString);
      } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(rawString)) {
        const [day, month, year] = rawString.split('/').map(Number);
        if (!Number.isNaN(day) && !Number.isNaN(month) && !Number.isNaN(year)) {
          time = Date.UTC(year, month - 1, day);
        }
      } else {
        time = Date.parse(rawString);
      }
      if (Number.isNaN(time)) {
        return { blank: true, value: 0, type };
      }
      return { blank: false, value: time, type };
    }
    return { blank: isBlank, value: rawString.toLowerCase(), type: 'text' };
  }

  function applyColumna1Sort(table, th, order) {
    if (!table || !th) return;
    const tbody = table.tBodies[0];
    if (!tbody) return;
    const headers = Array.from(table.querySelectorAll('thead th'));
    const index = headers.indexOf(th);
    if (index === -1) return;
    const rows = Array.from(tbody.querySelectorAll('tr'));
    rows.sort((a, b) => {
      const aCell = a.children[index];
      const bCell = b.children[index];
      const aVal = parseSortableCell(aCell);
      const bVal = parseSortableCell(bCell);
      if (aVal.blank && bVal.blank) return 0;
      if (aVal.blank !== bVal.blank) {
        return aVal.blank ? 1 : -1;
      }
      let comparison = 0;
      if (aVal.type === 'number' && bVal.type === 'number') {
        comparison = aVal.value - bVal.value;
      } else if (aVal.type === 'date' && bVal.type === 'date') {
        comparison = aVal.value - bVal.value;
      } else if (TABLE_COLLATOR) {
        comparison = TABLE_COLLATOR.compare(aVal.value, bVal.value);
      } else {
        comparison = aVal.value < bVal.value ? -1 : aVal.value > bVal.value ? 1 : 0;
      }
      if (comparison === 0) return 0;
      return order === 'asc' ? (comparison < 0 ? -1 : 1) : (comparison < 0 ? 1 : -1);
    });
    rows.forEach((row) => tbody.appendChild(row));
  }

  function updateColumna1HeaderState(headers, active, order) {
    headers.forEach((header) => {
      if (header === active) {
        header.dataset.sortOrder = order;
        header.classList.toggle('sorted-asc', order === 'asc');
        header.classList.toggle('sorted-desc', order === 'desc');
      } else {
        header.dataset.sortOrder = '';
        header.classList.remove('sorted-asc', 'sorted-desc');
      }
    });
  }

  function reapplyColumna1Sort(table) {
    if (!table) return;
    const active = table.querySelector('thead th.sorted-asc, thead th.sorted-desc');
    if (!active) return;
    const order = active.dataset.sortOrder || (active.classList.contains('sorted-desc') ? 'desc' : 'asc');
    applyColumna1Sort(table, active, order || 'asc');
  }

  function initColumna1Sorting(root = document) {
    root.querySelectorAll('.columna-1-table').forEach((table) => {
      const tbody = table.tBodies[0];
      if (!tbody) return;
      const headers = Array.from(table.querySelectorAll('thead th'));
      headers.forEach((th, index) => {
        if (th.dataset.sortableInit === '1') return;
        th.dataset.sortableInit = '1';
        th.classList.add('sortable');
        th.addEventListener('click', () => {
          const order = th.dataset.sortOrder === 'asc' ? 'desc' : 'asc';
          updateColumna1HeaderState(headers, th, order);
          applyColumna1Sort(table, th, order);
        });
      });
    });
  }

  function escapeHtml(value) {
    if (value === undefined || value === null) return '';
    return value
      .toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function normalizePartValue(value) {
    if (value === undefined || value === null) return '';
    const text = `${value}`.trim();
    if (!text) return '';
    const lower = text.toLowerCase();
    if (lower === 'none' || lower === 'null' || lower === 'undefined') return '';
    return text;
  }

  function formatPartSuffix(value) {
    const normalized = normalizePartValue(value);
    if (!normalized) return '';
    const num = Number(normalized);
    if (!Number.isFinite(num)) return '';
    return ` (${Math.trunc(num) + 1})`;
  }

  function parseSplitHours(value) {
    if (value === undefined || value === null || value === '') return null;
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function toSplitInputValue(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 100) / 100;
    if (Number.isInteger(rounded)) return `${rounded}`;
    return rounded.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
  }

  function formatSplitNumber(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 100) / 100;
    if (Number.isInteger(rounded)) return `${rounded}`;
    return rounded.toLocaleString('es-ES', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
  }

  function formatSplitDuration(value) {
    if (!Number.isFinite(value)) return '';
    const total = value < 0 ? 0 : value;
    const days = Math.floor(total / SPLIT_WORKDAY_HOURS);
    const remainderRaw = total - (days * SPLIT_WORKDAY_HOURS);
    const remainder = Math.round(remainderRaw * 100) / 100;
    const parts = [];
    if (days > 0) parts.push(`${days} día${days === 1 ? '' : 's'}`);
    if (remainder > 0 || parts.length === 0) {
      const hoursText = formatSplitNumber(remainder);
      const hoursLabel = remainder === 1 ? 'hora' : 'horas';
      parts.push(`${hoursText} ${hoursLabel}`);
    }
    return parts.join(' y ');
  }

  function formatSplitHint(value) {
    const duration = formatSplitDuration(value);
    return duration ? `(${duration})` : '';
  }

  function splitOrdinalLabel(index) {
    if (!Number.isInteger(index) || index < 0) return 'Horas parte';
    if (index < SPLIT_ORDINAL_WORDS.length) {
      return `Horas ${SPLIT_ORDINAL_WORDS[index]} parte`;
    }
    return `Horas parte ${index + 1}`;
  }

  function getSplitManualInputs() {
    if (!splitPartsContainer) return [];
    return Array.from(
      splitPartsContainer.querySelectorAll('input.split-part-input[data-manual="true"]')
    );
  }

  function ensureSplitRemainderInput() {
    if (!splitPartsContainer) return null;
    if (splitRemainderInput && splitRemainderInput.isConnected) {
      return splitRemainderInput;
    }
    const row = document.createElement('div');
    row.className = 'split-part-row split-remainder-row';
    const label = document.createElement('label');
    const labelSpan = document.createElement('span');
    labelSpan.className = 'split-part-label';
    label.appendChild(labelSpan);
    const input = document.createElement('input');
    input.type = 'number';
    input.readOnly = true;
    input.tabIndex = -1;
    input.className = 'split-part-input split-part-remainder';
    input.dataset.manual = 'false';
    label.appendChild(input);
    const hint = document.createElement('span');
    hint.className = 'split-hours-hint';
    label.appendChild(hint);
    row.appendChild(label);
    splitPartsContainer.appendChild(row);
    input._hintElement = hint;
    input._labelElement = labelSpan;
    splitRemainderInput = input;
    return splitRemainderInput;
  }

  function refreshSplitPartLabels() {
    const manuals = getSplitManualInputs();
    manuals.forEach((input, idx) => {
      if (input && input._labelElement) {
        input._labelElement.textContent = `${splitOrdinalLabel(idx)}:`;
      }
    });
    if (splitRemainderInput && splitRemainderInput._labelElement) {
      splitRemainderInput._labelElement.textContent = `${splitOrdinalLabel(manuals.length)}:`;
    }
  }

  function createSplitPartRow(initialValue, beforeElement) {
    if (!splitPartsContainer) return null;
    const row = document.createElement('div');
    row.className = 'split-part-row';
    const label = document.createElement('label');
    const labelSpan = document.createElement('span');
    labelSpan.className = 'split-part-label';
    label.appendChild(labelSpan);
    const input = document.createElement('input');
    input.type = 'number';
    input.min = '1';
    input.step = '1';
    input.required = true;
    input.className = 'split-part-input';
    input.dataset.manual = 'true';
    if (initialValue !== null && Number.isFinite(initialValue) && initialValue > 0) {
      input.value = toSplitInputValue(initialValue);
    }
    input.addEventListener('input', () => {
      input.classList.remove('split-input-error');
      updateSplitModalDisplay();
    });
    label.appendChild(input);
    const hint = document.createElement('span');
    hint.className = 'split-hours-hint';
    label.appendChild(hint);
    row.appendChild(label);
    input._hintElement = hint;
    input._labelElement = labelSpan;
    if (beforeElement) {
      splitPartsContainer.insertBefore(row, beforeElement);
    } else {
      splitPartsContainer.appendChild(row);
    }
    return input;
  }

  function resetSplitParts(existingParts) {
    if (!splitPartsContainer) return;
    splitPartsContainer.innerHTML = '';
    splitRemainderInput = null;
    const normalized = Array.isArray(existingParts)
      ? existingParts
          .map(value => parseSplitHours(value))
          .filter(value => Number.isFinite(value) && value > 0)
      : [];
    let manualValues = [];
    let remainderValue = null;
    if (normalized.length >= 2) {
      manualValues = normalized.slice(0, normalized.length - 1);
      remainderValue = normalized[normalized.length - 1];
    } else if (normalized.length === 1) {
      manualValues = [normalized[0]];
    }
    if (!manualValues.length) {
      manualValues = [null];
    }
    manualValues.forEach(value => {
      createSplitPartRow(value, null);
    });
    const remainder = ensureSplitRemainderInput();
    if (remainder) {
      if (remainderValue !== null) {
        remainder.value = toSplitInputValue(remainderValue);
      } else {
        remainder.value = '';
      }
    }
    refreshSplitPartLabels();
    updateSplitModalDisplay();
  }

  function updateSplitModalDisplay() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    if (splitTotalDisplay) {
      if (total === null) {
        splitTotalDisplay.textContent = '';
      } else {
        const baseNumber = formatSplitNumber(total);
        const hoursLabel = total === 1 ? 'hora' : 'horas';
        const duration = formatSplitDuration(total);
        splitTotalDisplay.textContent = `Total fase: ${baseNumber} ${hoursLabel}${duration ? ` (${duration})` : ''}`;
      }
    }
    const manuals = getSplitManualInputs();
    let manualSum = 0;
    manuals.forEach(input => {
      const value = parseSplitHours(input.value);
      if (Number.isFinite(value)) {
        manualSum += value;
      }
      if (input._hintElement) {
        input._hintElement.textContent = Number.isFinite(value) ? formatSplitHint(value) : '';
      }
      if (total !== null && Number.isFinite(total)) {
        input.setAttribute('max', total);
      } else {
        input.removeAttribute('max');
      }
    });
    if (splitRemainderInput) {
      let remainderValue = null;
      if (total !== null && Number.isFinite(total)) {
        remainderValue = total - manualSum;
      }
      if (Number.isFinite(remainderValue)) {
        const cleanValue = Math.max(remainderValue, 0);
        splitRemainderInput.value = toSplitInputValue(cleanValue);
        splitRemainderInput.classList.toggle('split-input-error', remainderValue <= 0);
        if (splitRemainderInput._hintElement) {
          splitRemainderInput._hintElement.textContent = formatSplitHint(cleanValue);
        }
      } else {
        splitRemainderInput.value = '';
        splitRemainderInput.classList.remove('split-input-error');
        if (splitRemainderInput._hintElement) {
          splitRemainderInput._hintElement.textContent = '';
        }
      }
    }
    refreshSplitPartLabels();
  }

  function prepareSplitModal(button) {
    if (!splitModal) return;
    const totalAttr = button ? parseSplitHours(button.dataset.totalHours) : null;
    const fallbackAttr = button ? parseSplitHours(button.dataset.hours) : null;
    let total = totalAttr !== null ? totalAttr : fallbackAttr;
    let existingParts = [];
    if (button) {
      const pid = button.dataset.pid;
      const phase = button.dataset.phase;
      if (pid && phase && PROJECT_DATA[pid] && PROJECT_DATA[pid].phases) {
        const phaseEntry = PROJECT_DATA[pid].phases[phase];
        if (Array.isArray(phaseEntry)) {
          existingParts = phaseEntry;
          const computedTotal = phaseEntry
            .map(value => parseSplitHours(value))
            .filter(value => Number.isFinite(value) && value > 0)
            .reduce((acc, value) => acc + value, 0);
          if (Number.isFinite(computedTotal) && computedTotal > 0) {
            total = computedTotal;
          }
        }
      }
    }
    if (total !== null && Number.isFinite(total)) {
      splitModal.dataset.totalHours = total;
    } else {
      delete splitModal.dataset.totalHours;
    }
    resetSplitParts(existingParts);
    if (fallbackAttr && Number.isFinite(fallbackAttr)) {
      const manuals = getSplitManualInputs();
      if (manuals.length) {
        const first = manuals[0];
        const currentValue = parseSplitHours(first.value);
        if (!(Number.isFinite(currentValue) && Math.abs(currentValue - fallbackAttr) < 1e-6)) {
          first.value = toSplitInputValue(fallbackAttr);
        }
      }
    }
    updateSplitModalDisplay();
    const manuals = getSplitManualInputs();
    if (manuals.length) {
      manuals[0].focus();
    }
  }

  function pickClientDate(info) {
    if (!info) return '';
    const directCandidates = [
      info.client_date,
      info.client_due_date,
      info.customer_date,
    ];
    for (const value of directCandidates) {
      if (value === undefined || value === null) continue;
      const text = `${value}`.trim();
      if (text && text !== '0') return text;
    }
    const fields = info.kanban_display_fields || {};
    const labels = ['Fecha Cliente', 'Fecha cliente'];
    for (const label of labels) {
      const raw = fields[label];
      if (raw === undefined || raw === null) continue;
      const text = `${raw}`.trim();
      if (text) return text;
    }
    return '';
  }

  function updateSplitModalDisplay() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    if (splitTotalDisplay) {
      if (total === null) {
        splitTotalDisplay.textContent = '';
      } else {
        const baseNumber = formatSplitNumber(total);
        const hoursLabel = total === 1 ? 'hora' : 'horas';
        const duration = formatSplitDuration(total);
        splitTotalDisplay.textContent = `Total fase: ${baseNumber} ${hoursLabel}${duration ? ` (${duration})` : ''}`;
      }
    }
    if (splitPart1Hint) {
      const value = splitPart1 ? parseSplitHours(splitPart1.value) : null;
      splitPart1Hint.textContent = value === null ? '' : formatSplitHint(value);
    }
    if (splitPart2Hint) {
      const value = splitPart2 ? parseSplitHours(splitPart2.value) : null;
      splitPart2Hint.textContent = value === null ? '' : formatSplitHint(value);
    }
  }

  function handleSplitPart1Input() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    const value = splitPart1 ? parseSplitHours(splitPart1.value) : null;
    if (splitPart2) {
      if (total === null || value === null) {
        splitPart2.value = '';
      } else {
        let remainder = total - value;
        if (remainder < 0) remainder = 0;
        splitPart2.value = toSplitInputValue(remainder);
      }
    }
    updateSplitModalDisplay();
  }

  function handleSplitPart2Input() {
    updateSplitModalDisplay();
  }

  function prepareSplitModal(button) {
    if (!splitModal) return;
    const totalAttr = button ? parseSplitHours(button.dataset.totalHours) : null;
    const fallbackAttr = button ? parseSplitHours(button.dataset.hours) : null;
    const total = totalAttr !== null ? totalAttr : fallbackAttr;
    if (total !== null) {
      splitModal.dataset.totalHours = total;
    } else {
      delete splitModal.dataset.totalHours;
    }
    if (splitPart1) {
      splitPart1.value = '';
      if (total !== null) splitPart1.setAttribute('max', total);
      else splitPart1.removeAttribute('max');
    }
    if (splitPart2) {
      splitPart2.value = '';
      if (total !== null) splitPart2.setAttribute('max', total);
      else splitPart2.removeAttribute('max');
    }
    updateSplitModalDisplay();
  }

  function norm(value) {
    return (value || '').toString().trim().toLowerCase();
  }

  function resolveRowPid(row) {
    if (!row) return null;
    let pid = row.dataset.pid;
    if (pid && PROJECT_DATA[pid]) {
      const cell = row.querySelector('.observations-cell');
      if (cell) syncObservationsCell(cell, pid);
      return pid;
    }

    const code = norm(row.dataset.code);
    const project = norm(row.dataset.project);
    const title = norm(row.dataset.title);
    const display = norm(row.dataset.display);
    const client = norm(row.dataset.client);

    for (const [candidatePid, info] of Object.entries(PROJECT_DATA)) {
      if (!info) continue;
      const name = norm(info.name);
      if (!name) continue;
      const [nameProject, ...rest] = name.split(' - ');
      const nameClient = norm(rest.join(' - '));
      const projectMatch = norm(nameProject);
      const codeMatch = norm(info.custom_card_id);

      if (code && codeMatch && code === codeMatch) {
        pid = candidatePid;
      } else if (code && name.includes(code)) {
        pid = candidatePid;
      } else if (project && projectMatch === project) {
        pid = candidatePid;
      } else if (title && (name === title || name.startsWith(title) || title.startsWith(name))) {
        pid = candidatePid;
      } else if (display && name === display) {
        pid = candidatePid;
      } else if (project && name.includes(project) && (!client || !nameClient || client === nameClient)) {
        pid = candidatePid;
      }

      if (pid) {
        row.dataset.pid = pid;
        const cell = row.querySelector('.observations-cell');
        if (cell) syncObservationsCell(cell, pid);
        return pid;
      }
    }
    return null;
  }

  function clearStartDayHighlight() {
    if (startDayHighlightCell && startDayHighlightCell.isConnected) {
      startDayHighlightCell.classList.remove(START_DAY_HIGHLIGHT_CLASS);
    }
    startDayHighlightCell = null;
  }

  function applyStartDayHighlight(dateValue) {
    const iso = normalizeDateToIso(dateValue);
    clearStartDayHighlight();
    if (!iso) return;
    const cell = document.querySelector(`.pedidos-calendar td[data-date='${iso}']`);
    if (cell) {
      cell.classList.add(START_DAY_HIGHLIGHT_CLASS);
      startDayHighlightCell = cell;
    }
  }

  function resolvePlannedStartByPid(pid) {
    if (!pid) return '';
    const candidates = new Set();
    const startEntry = START_DATA && START_DATA[pid];
    if (startEntry && typeof startEntry === 'object') {
      Object.values(startEntry).forEach(value => {
        const iso = normalizeDateToIso(value);
        if (iso) candidates.add(iso);
      });
    }
    const info = PROJECT_DATA && PROJECT_DATA[pid];
    if (info) {
      ['plan_start', 'montar_start', 'start', 'start_date'].forEach(key => {
        const iso = normalizeDateToIso(info && info[key]);
        if (iso) candidates.add(iso);
      });
      if (info.segment_starts && typeof info.segment_starts === 'object') {
        Object.values(info.segment_starts).forEach(value => {
          const iso = normalizeDateToIso(value);
          if (iso) candidates.add(iso);
        });
      }
    }
    if (!candidates.size) return '';
    return Array.from(candidates).sort()[0];
  }

  function resolvePlannedStartFromRow(row) {
    if (!row) return '';
    const direct = normalizeDateToIso(row.dataset.plan);
    if (direct) return direct;
    const pid = resolveRowPid(row);
    if (!pid) return '';
    return resolvePlannedStartByPid(pid);
  }

  function highlightProjectStartByPid(pid) {
    applyStartDayHighlight(resolvePlannedStartByPid(pid));
  }

  function highlightProjectStartByRow(row) {
    applyStartDayHighlight(resolvePlannedStartFromRow(row));
  }

  function afterMove(data, originalDate) {
    localStorage.setItem(LAST_KEY, JSON.stringify({pid: data.pid, phase: data.phase, part: data.part, date: data.date}));
    if (data.date !== originalDate) localStorage.setItem(SCROLL_KEY2, data.date);
    location.reload();
  }

  function makeDraggable(el) {
    if (!el) return;
    let startX, startY, startLeft, startTop;
    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      el.style.left = startLeft + dx + 'px';
      el.style.top = startTop + dy + 'px';
    };
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    el.addEventListener('mousedown', (ev) => {
      if (ev.target.closest('input, textarea, select, button')) return;
      startX = ev.clientX;
      startY = ev.clientY;
      const rect = el.getBoundingClientRect();
      startLeft = rect.left + window.scrollX;
      startTop = rect.top + window.scrollY;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }

  document.addEventListener('click', () => {
    if (popup) popup.style.display = 'none';
  });
  if (popup) {
    popup.addEventListener('click', (e) => e.stopPropagation());
  }

  document.querySelectorAll('.modal-content, .conflict-content, .info-popup').forEach(makeDraggable);

  if (splitCancel) {
    splitCancel.addEventListener('click', () => { if (splitModal) splitModal.style.display = 'none'; });
  }
  if (splitForm && !splitForm.dataset.enhanced) {
    splitForm.addEventListener('submit', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (!splitModal) return;
      const manuals = getSplitManualInputs();
      if (!manuals.length) {
        alert('Debes indicar al menos una parte.');
        return;
      }
      const parts = [];
      let invalid = false;
      manuals.forEach(input => {
        const value = parseSplitHours(input.value);
        if (!Number.isInteger(value) || value <= 0) {
          input.classList.add('split-input-error');
          invalid = true;
          return;
        }
        parts.push(value);
      });
      const remainderValue = splitRemainderInput ? parseSplitHours(splitRemainderInput.value) : null;
      const total = parseSplitHours(splitModal.dataset.totalHours);
      let remainderInt = null;
      if (!Number.isInteger(remainderValue) || remainderValue === null || remainderValue <= 0) {
        invalid = true;
      } else {
        remainderInt = remainderValue;
        parts.push(remainderInt);
      }
      const sumParts = parts.reduce((acc, value) => acc + value, 0);
      if (total !== null && Number.isFinite(total) && sumParts !== total) {
        invalid = true;
      }
      if (invalid) {
        alert('Revisa las horas de cada parte. Deben ser enteros positivos y sumar el total de la fase.');
        updateSplitModalDisplay();
        return;
      }
      fetch(SPLIT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({
          pid: splitModal.dataset.pid,
          phase: splitModal.dataset.phase,
          date: splitModal.dataset.date,
          parts,
        })
      }).then(resp => { if (resp.ok) location.reload(); else resp.json().then(d => alert(d.error || 'Error')); });
    });
    splitForm.dataset.enhanced = 'true';
  }

  if (splitAddPartButton && !splitAddPartButton.dataset.bound) {
    splitAddPartButton.addEventListener('click', ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const remainderRow = splitRemainderInput ? splitRemainderInput.closest('.split-part-row') : null;
      const input = createSplitPartRow(null, remainderRow);
      ensureSplitRemainderInput();
      updateSplitModalDisplay();
      if (input) input.focus();
    });
    splitAddPartButton.dataset.bound = 'true';
  }

  function buildPhaseSection(info, context) {
    const phaseLines = [];
    PHASES.forEach(ph => {
      if (ph === 'dibujo' || ph === 'pedidos') return;
      const raw = info.phases ? info.phases[ph] : null;
      let total = 0;
      if (Array.isArray(raw)) total = raw.map(v => parseInt(v)).reduce((a,b) => a + b, 0);
      else total = parseInt(raw) || 0;
      if (total > 0) {
        const assigned = (info.assigned && info.assigned[ph]) || 'Sin planificar';
        const classes = ['phase-entry'];
        classes.push(assigned === 'Sin planificar' ? 'unplanned' : 'planned');
        const isActivePhase = ph === context.phase;
        const partSuffix = isActivePhase ? formatPartSuffix(context.part) : '';
        let line = `<div class="${classes.join(' ')}">${ph}${partSuffix}: ${total}h`;
        if (isActivePhase) {
          const partValue = normalizePartValue(context.part);
          const partAttr = partValue ? ` data-part="${partValue}"` : '';
          line += ` <form id="phase-hours-form" style="display:inline"><input type="number" id="phase-hours-input" value="${total}" min="1" required><button type="submit" data-pid="${context.pid}" data-phase="${ph}"${partAttr}>Cambiar horas</button></form>`;
        }
        line += `</div>`;
        phaseLines.push(line);
      }
    });
    let section = '';
    if (phaseLines.length) section += phaseLines.join('');
    if (context.phase === 'pedidos') {
      const acopio = info.phases ? info.phases['pedidos'] : null;
      if (acopio && acopio !== '0') section += `<div>Plazo acopio: ${acopio}</div>`;
    }
    return section;
  }

  function openPhasePopup(context, anchorRect) {
    if (!popup) return;
    const info = PROJECT_DATA[context.pid];
    if (!info) return;
    const headerParts = [info.name];
    if (info.blocked) headerParts[0] += ' <span class="blocked-sign">\u{1F6AB}</span>';
    headerParts.push(info.client || '');
    if (context.phase) headerParts.push(`${context.phase}${formatPartSuffix(context.part)}`);
    let html = `<div class="popup-section popup-header"><strong>${headerParts.filter(Boolean).join(' - ')}</strong></div>`;
    const metaLines = [];
    const clientDate = pickClientDate(info);
    if (clientDate) metaLines.push(`<div>Fecha cliente: ${clientDate}</div>`);
    const safeProjectAttr = escapeHtml(context.project || info.name || '');
    const safePidAttr = escapeHtml(context.pid || '');
    metaLines.push(`<div><button type="button" class="view-calendar-btn" data-project="${safeProjectAttr}" data-pid="${safePidAttr}">Ver calendario</button></div>`);
    if (info.due_date && info.due_date !== '0') metaLines.push(`<div>Límite: ${info.due_date}</div>`);
    if (info.material_confirmed_date && info.material_confirmed_date !== '0') metaLines.push(`<div>Material confirmado: ${info.material_confirmed_date}</div>`);
    if (metaLines.length) html += `<div class="popup-section">${metaLines.join('')}</div>`;
    const kanbanFields = info.kanban_display_fields || {};
    const kanbanEntries = Object.entries(kanbanFields).filter(([, value]) => value !== null && value !== undefined && `${value}`.trim() !== '');
    if (kanbanEntries.length) {
      let kanbanHtml = '<div class="popup-section kanban-extra-fields">';
      kanbanEntries.forEach(([label, value]) => {
        kanbanHtml += `<div>${label}: ${value}</div>`;
      });
      kanbanHtml += '</div>';
      html += kanbanHtml;
    }
    const phaseSection = buildPhaseSection(info, context);
    if (phaseSection) html += `<div class="popup-section">${phaseSection}</div>`;
    const actionLines = [];
    if (context.phase) {
      const startVal = (START_DATA[context.pid] && START_DATA[context.pid][context.phase]) || '';
      actionLines.push(`<div>Inicio de la fase: <form id="start-form" style="display:inline"><input type="date" id="start-input" value="${startVal}" required><button type="submit" id="start-btn" data-pid="${context.pid}" data-phase="${context.phase}">Cambiar</button></form></div>`);
      actionLines.push(`<div><button id="freeze-btn" data-pid="${context.pid}" data-phase="${context.phase}" style="color:red;font-weight:bold">${(info.frozen_phases && info.frozen_phases.includes(context.phase)) ? 'Descongelar' : 'Congelar'}</button></div>`);
      const phaseHoursEntry = info.phases ? info.phases[context.phase] : null;
      let totalPhaseHours = null;
      if (Array.isArray(phaseHoursEntry)) {
        totalPhaseHours = phaseHoursEntry
          .map(v => Number(v) || 0)
          .reduce((acc, val) => acc + val, 0);
      } else if (phaseHoursEntry !== undefined && phaseHoursEntry !== null && `${phaseHoursEntry}`.trim() !== '') {
        const parsedPhase = Number(phaseHoursEntry);
        if (Number.isFinite(parsedPhase)) totalPhaseHours = parsedPhase;
      }
      const totalHoursAttr = totalPhaseHours !== null ? ` data-total-hours="${totalPhaseHours}"` : '';
      const partHoursAttr = totalPhaseHours !== null ? ` data-hours="${totalPhaseHours}"` : '';
      if (info.phases && Array.isArray(info.phases[context.phase])) {
        const splitLine = `<div><button id="unsplit-btn" data-pid="${context.pid}" data-phase="${context.phase}">Deshacer división</button></div>`;
        actionLines.push(splitLine);
      }
      actionLines.push(`<div><button class="phase-delete-btn" id="del-btn" data-pid="${context.pid}" data-phase="${context.phase}">&#10060; Borrar fase</button></div>`);
      const unplanPart = normalizePartValue(context.part);
      const unplanAttr = unplanPart ? ` data-part="${unplanPart}"` : '';
      actionLines.push(`<div><button id="unplan-btn" data-pid="${context.pid}" data-phase="${context.phase}"${unplanAttr}>Sin planificar</button></div>`);
    }
    const obsValue = info && info.observations !== undefined && info.observations !== null
      ? `${info.observations}`
      : '';
    const safeObsValue = escapeHtml(obsValue);
    actionLines.push(`
      <div class="popup-observations">
        <label for="obs-text">Observaciones</label>
        <textarea id="obs-text" data-pid="${context.pid}" class="popup-observations-text">${safeObsValue}</textarea>
        <div class="popup-observations-actions">
          <button type="button" id="obs-save" data-pid="${context.pid}">Guardar</button>
        </div>
      </div>
    `);
    if (info.image) {
      const imgUrl = `${STATIC_URL}${info.image}`;
      actionLines.push(`<div><a href="${imgUrl}" target="_blank"><img src="${imgUrl}" style="max-width:200px;display:block;margin-top:4px;"></a></div>`);
    }
    if (info.kanban_attachments && info.kanban_attachments.length) {
      info.kanban_attachments.forEach(att => {
        const url = att.url;
        const name = (att.name || '').toLowerCase();
        if (/\.(png|jpe?g|gif|webp|bmp|svg)$/.test(name)) {
          actionLines.push(`<div><a href="${url}" target="_blank"><img src="${url}" alt="${att.name || ''}" style="max-width:200px;display:block;margin-top:4px;"></a></div>`);
        } else {
          actionLines.push(`<div><a href="${url}" target="_blank">${att.name || url}</a></div>`);
        }
      });
    }
    if (actionLines.length) html += `<div class="popup-section">${actionLines.join('')}</div>`;
    popup.innerHTML = html;
    popup.style.left = (anchorRect.left + window.scrollX + 5) + 'px';
    popup.style.top = (anchorRect.bottom + window.scrollY + 5) + 'px';
    popup.style.display = 'block';

    const viewCalendarBtn = popup.querySelector('.view-calendar-btn');
    if (viewCalendarBtn) {
      viewCalendarBtn.addEventListener('click', ev => {
        ev.stopPropagation();
        try {
          const url = new URL(COMPLETE_URL, window.location.origin);
          const pidValue = viewCalendarBtn.dataset.pid || '';
          if (pidValue) {
            url.searchParams.set('project_id', pidValue);
            url.searchParams.set('highlight', pidValue);
          }
          const projectName = viewCalendarBtn.dataset.project || '';
          if (projectName) {
            const ofMatch = projectName.match(/\bOF\s*(\d{4})\b/i);
            const filterValue = ofMatch ? ofMatch[1] : projectName;
            url.searchParams.set('project', filterValue);
          }
          window.open(url.toString(), '_blank');
        } catch (error) {
          console.error('No se pudo abrir el calendario de planificación:', error);
        }
      });
    }

    const del = document.getElementById('del-btn');
    if (del) {
      del.addEventListener('click', ev => {
        ev.stopPropagation();
        if (confirm('¿Borrar fase?')) {
          fetch(DELETE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ pid: del.dataset.pid, phase: del.dataset.phase })
          }).then(() => location.reload());
        }
      });
    }
    const unplan = document.getElementById('unplan-btn');
    if (unplan) {
      unplan.addEventListener('click', ev => {
        ev.stopPropagation();
        const today = madridDateISO();
        const body = { pid: unplan.dataset.pid, phase: unplan.dataset.phase, date: today, worker: 'Sin planificar' };
        const partValue = normalizePartValue(unplan.dataset.part);
        if (partValue) body.part = partValue;
        fetch(MOVE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify(body)
        })
          .then(resp => resp.json().then(d => ({ ok: resp.ok, data: d })))
          .then(({ ok, data }) => {
            if (!ok) {
              alert(data.error || 'Error');
              return;
            }
            afterMove(data, today);
          });
      });
    }
    const obsSave = document.getElementById('obs-save');
    const obsText = document.getElementById('obs-text');
    if (obsSave && obsText) {
      obsSave.addEventListener('click', ev => {
        ev.stopPropagation();
        const pid = obsSave.dataset.pid;
        const txt = obsText.value;
        const url = OBS_URL_TEMPLATE.replace('__PID__', encodeURIComponent(pid));
        const originalLabel = obsSave.textContent;
        obsSave.disabled = true;
        obsSave.textContent = 'Guardando...';
        fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify({ observations: txt })
        })
          .then(resp => {
            if (resp.ok) {
              return resp.text().catch(() => '');
            }
            return resp.json().catch(() => ({})).then(data => {
              throw new Error(data.error || 'Error guardando observaciones');
            });
          })
          .then(() => {
            if (PROJECT_DATA[pid]) PROJECT_DATA[pid].observations = txt;
            obsSave.textContent = 'Guardado';
            setTimeout(() => { obsSave.textContent = originalLabel; }, 1500);
          })
          .catch(err => {
            alert(err.message || 'Error guardando observaciones');
            obsSave.textContent = originalLabel;
          })
          .finally(() => {
            obsSave.disabled = false;
          });
      });
    }
    const splitBtn = document.getElementById('split-btn');
    if (splitBtn && splitModal) {
      splitBtn.addEventListener('click', ev => {
        ev.stopPropagation();
        splitModal.dataset.pid = splitBtn.dataset.pid;
        splitModal.dataset.phase = splitBtn.dataset.phase;
        splitModal.dataset.date = splitBtn.dataset.date;
        prepareSplitModal(splitBtn);
        splitModal.style.display = 'block';
      });
    }
    const unsplitBtn = document.getElementById('unsplit-btn');
    if (unsplitBtn) {
      unsplitBtn.addEventListener('click', ev => {
        ev.stopPropagation();
        if (confirm('¿Deshacer división de esta fase?')) {
          fetch(UNSPLIT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ pid: unsplitBtn.dataset.pid, phase: unsplitBtn.dataset.phase })
          }).then(resp => { if (resp.ok) location.reload(); else resp.json().then(d => alert(d.error || 'Error')); });
        }
      });
    }
    const freeze = document.getElementById('freeze-btn');
    if (freeze) {
      freeze.addEventListener('click', ev => {
        ev.stopPropagation();
        fetch('/toggle_freeze/' + freeze.dataset.pid + '/' + encodeURIComponent(freeze.dataset.phase), { method: 'POST', credentials: 'same-origin' })
          .then(() => location.reload());
      });
    }
    const startForm = document.getElementById('start-form');
    if (startForm) {
      startForm.addEventListener('submit', ev => {
        ev.preventDefault();
        ev.stopPropagation();
        const btn = document.getElementById('start-btn');
        const val = document.getElementById('start-input').value;
        fetch(START_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify({ pid: btn.dataset.pid, phase: btn.dataset.phase, date: val })
        }).then(resp => {
          if (!resp.ok) {
            return resp.json().then(d => { alert(d.error || 'Error'); return null; });
          }
          return resp.json();
        }).then(d => {
          if (d) {
            localStorage.setItem(LAST_KEY, JSON.stringify({pid: btn.dataset.pid, phase: btn.dataset.phase, date: d.date}));
            if (d.date !== val) localStorage.setItem(SCROLL_KEY2, d.date);
          }
          location.reload();
        });
      });
    }
    const hoursForm = document.getElementById('phase-hours-form');
    if (hoursForm) {
      hoursForm.addEventListener('submit', ev => {
        ev.preventDefault();
        ev.stopPropagation();
        const btn = hoursForm.querySelector('button');
        const val = document.getElementById('phase-hours-input').value;
        const payload = { pid: btn.dataset.pid, phase: btn.dataset.phase, hours: val };
        const partValue = normalizePartValue(btn.dataset.part);
        if (partValue) {
          payload.part = partValue;
        }
        fetch(PHASE_HOURS_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify(payload)
        }).then(resp => {
          if (resp.ok) {
            const url = new URL(location);
            url.searchParams.set('highlight', btn.dataset.pid);
            location.href = url;
          } else {
            resp.json().then(d => alert(d.error || 'Error'));
          }
        });
      });
    }
  }
  recalcCalendarHeights();

  let draggedTask = null;
  let dragSourceCell = null;

  function buildTaskDragPayload(element) {
    const payload = {};
    if (!element || !element.dataset) {
      return payload;
    }
    if (element.dataset.pid) {
      payload.pid = element.dataset.pid;
    }
    if (element.dataset.phase) {
      payload.phase = element.dataset.phase;
    }
    const partValue = normalizePartValue(element.dataset.part);
    if (partValue) {
      payload.part = partValue;
    }
    if (element.dataset.worker) {
      payload.worker = element.dataset.worker;
    }
    if (element.dataset.cid) {
      payload.cid = element.dataset.cid;
    }
    if (element.dataset.quickCardId) {
      payload.quickCardId = element.dataset.quickCardId;
    }
    return payload;
  }

  function handleTaskDragStart(event) {
    draggedTask = event.currentTarget;
    dragSourceCell = draggedTask ? draggedTask.closest('td[data-date], td.unconfirmed') : null;
    const payload = buildTaskDragPayload(draggedTask);
    if (event.dataTransfer) {
      event.dataTransfer.effectAllowed = 'move';
      try {
        event.dataTransfer.setData('text/plain', JSON.stringify(payload));
      } catch (error) {
        // Ignore serialization issues
      }
    }
    if (draggedTask) {
      draggedTask.classList.add('task-dragging');
    }
  }

  function handleTaskDragEnd() {
    if (draggedTask) {
      draggedTask.classList.remove('task-dragging');
    }
    draggedTask = null;
    dragSourceCell = null;
  }

  function initTaskDrag(taskElement) {
    if (!taskElement || taskElement.dataset.dragInit === '1') {
      return;
    }
    taskElement.dataset.dragInit = '1';
    taskElement.addEventListener('dragstart', handleTaskDragStart);
    taskElement.addEventListener('dragend', handleTaskDragEnd);
  }

  function getTaskDropReference(cell, clientY) {
    const siblings = Array.from(cell.querySelectorAll('.task:not(.task-dragging)')).filter(element => element.offsetParent !== null);
    let closest = null;
    let closestOffset = Number.NEGATIVE_INFINITY;
    siblings.forEach((element) => {
      const rect = element.getBoundingClientRect();
      const offset = clientY - rect.top - (rect.height / 2);
      if (offset < 0 && offset > closestOffset) {
        closestOffset = offset;
        closest = element;
      }
    });
    return closest;
  }

  function finalizeQuickCardDrop(element, targetCell) {
    if (!element || !element.dataset || !element.dataset.quickCardId) {
      return;
    }
    const quickId = element.dataset.quickCardId;
    const targetKey = getCellStorageKey(targetCell);
    if (targetKey === UNCONFIRMED_ORDER_KEY) {
      element.dataset.day = '';
      element.dataset.due = '';
      updateQuickCardStoreDate(quickId, UNCONFIRMED_ORDER_KEY);
    } else if (targetKey) {
      element.dataset.day = targetKey;
      element.dataset.due = targetKey;
      updateQuickCardStoreDate(quickId, targetKey);
    }
    if (targetCell) {
      captureTaskOrderForCell(targetCell);
    }
    if (dragSourceCell && dragSourceCell !== targetCell) {
      captureTaskOrderForCell(dragSourceCell);
    }
  }

  function handleTaskDropOnCell(cell, event) {
    event.preventDefault();
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData('text/plain'));
    } catch (error) {
      data = {};
    }
    const reference = getTaskDropReference(cell, event.clientY);
    let activeTask = draggedTask;
    if (!activeTask && data && data.quickCardId) {
      activeTask = document.querySelector(`.task.quick-card[data-quick-card-id="${data.quickCardId}"]`);
    }
    if (activeTask) {
      if (reference) {
        cell.insertBefore(activeTask, reference);
      } else {
        cell.appendChild(activeTask);
      }
      captureTaskOrderForCell(cell);
      if (dragSourceCell && dragSourceCell !== cell) {
        captureTaskOrderForCell(dragSourceCell);
      }
      scheduleCalendarHeightRecalc();
    }
    if (data && data.pid) {
      fetch("{{ url_for('move_phase') }}", {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        credentials: 'same-origin',
        body: JSON.stringify({pid: data.pid, phase: data.phase, date: cell.dataset.date, worker: data.worker, part: data.part})
      }).then(resp => { if (resp.ok) location.reload(); });
    } else if (data && data.cid) {
      fetch("{{ url_for('update_pedido_date') }}", {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        credentials: 'same-origin',
        body: JSON.stringify({cid: data.cid, date: cell.dataset.date})
      }).then(resp => { if (resp.ok) location.reload(); });
    }
    const movedQuickCard = activeTask && activeTask.dataset && activeTask.dataset.quickCardId;
    if (movedQuickCard) {
      finalizeQuickCardDrop(activeTask, cell);
      scheduleCalendarHeightRecalc();
    }
    if (activeTask) {
      activeTask.classList.remove('task-dragging');
    }
    draggedTask = null;
    dragSourceCell = null;
  }

  const dayCells = document.querySelectorAll('.pedidos-calendar td[data-date]');
  dayCells.forEach(cell => {
    cell.addEventListener('dragover', e => {
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'move';
      }
    });
    cell.addEventListener('drop', event => {
      handleTaskDropOnCell(cell, event);
    });
  });

  const unconfirmedCell = document.querySelector('.pedidos-calendar td.unconfirmed');
  if (unconfirmedCell) {
    unconfirmedCell.addEventListener('dragover', e => {
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'move';
      }
    });
    unconfirmedCell.addEventListener('drop', e => {
      e.preventDefault();
      let data;
      try {
        data = JSON.parse(e.dataTransfer.getData('text/plain'));
      } catch (error) {
        data = {};
      }
      let activeTask = draggedTask;
      if (!activeTask && data && data.quickCardId) {
        activeTask = document.querySelector(`.task.quick-card[data-quick-card-id="${data.quickCardId}"]`);
      }
      if (activeTask) {
        unconfirmedCell.appendChild(activeTask);
        captureTaskOrderForCell(unconfirmedCell);
        if (dragSourceCell && dragSourceCell !== unconfirmedCell) {
          captureTaskOrderForCell(dragSourceCell);
        }
      }
      if (data && data.cid) {
        fetch("{{ url_for('update_pedido_date') }}", {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          credentials: 'same-origin',
          body: JSON.stringify({cid: data.cid, date: null})
        }).then(resp => { if (resp.ok) location.reload(); });
      }
      if (activeTask && activeTask.dataset && activeTask.dataset.quickCardId) {
        finalizeQuickCardDrop(activeTask, unconfirmedCell);
        scheduleCalendarHeightRecalc();
      } else if (activeTask) {
        scheduleCalendarHeightRecalc();
      }
      if (activeTask) {
        activeTask.classList.remove('task-dragging');
      }
      draggedTask = null;
      dragSourceCell = null;
    });
  }

  document.addEventListener('keydown', e => {
    if (e.key === 'a' || e.key === 'A') {
      const todayCell = document.querySelector('.pedidos-calendar td.today');
      if (todayCell) {
        todayCell.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }
  });

  function normalizeFilterValue(value) {
    return (value === undefined || value === null) ? '' : `${value}`.toLowerCase();
  }

  const filterStorage = (() => {
    try {
      if (typeof window === 'undefined' || !window.sessionStorage) {
        return null;
      }
      const probeKey = '__pedidosFilterProbe__';
      window.sessionStorage.setItem(probeKey, '1');
      window.sessionStorage.removeItem(probeKey);
      return window.sessionStorage;
    } catch (error) {
      return null;
    }
  })();

  function persistFilterValue(value) {
    if (!filterStorage) {
      return;
    }
    try {
      if (value) {
        filterStorage.setItem(FILTER_STORAGE_KEY, value);
      } else {
        filterStorage.removeItem(FILTER_STORAGE_KEY);
      }
    } catch (error) {
      // Ignore persistence issues
    }
  }

  function loadStoredFilterValue() {
    if (!filterStorage) {
      return null;
    }
    try {
      const value = filterStorage.getItem(FILTER_STORAGE_KEY);
      return value === null ? null : value;
    } catch (error) {
      return null;
    }
  }

  function updateFilterQueryParam(value) {
    if (typeof window === 'undefined' || !window.history || typeof window.history.replaceState !== 'function') {
      return;
    }
    try {
      const url = new URL(window.location.href);
      if (value) {
        url.searchParams.set('filter', value);
      } else {
        url.searchParams.delete('filter');
      }
      window.history.replaceState(null, '', url.toString());
    } catch (error) {
      // Ignore history issues
    }
  }

  function elementTextIncludes(element, query) {
    if (!query) return true;
    if (!element) return false;
    return element.textContent.toLowerCase().includes(query);
  }

  const filterInput = document.getElementById('filter-input');
  filterInput.addEventListener('input', () => {
    const rawValue = filterInput.value;
    const trimmedValue = rawValue.trim();
    const q = normalizeFilterValue(trimmedValue);
    document.querySelectorAll('.pedidos-calendar .task').forEach(t => {
      const proj = normalizeFilterValue(t.dataset.project);
      const cli = normalizeFilterValue(t.dataset.client);
      const code = normalizeFilterValue(t.dataset.code);
      const text = normalizeFilterValue(t.textContent);
      const showTask = !q || proj.includes(q) || cli.includes(q) || code.includes(q) || text.includes(q);
      t.style.display = showTask ? '' : 'none';
    });
    document.querySelectorAll('.columna-1 .project-row').forEach(row => {
      const proj = normalizeFilterValue(row.dataset.project);
      const title = normalizeFilterValue(row.dataset.title);
      const cli = normalizeFilterValue(row.dataset.client);
      const display = normalizeFilterValue(row.dataset.display);
      const code = normalizeFilterValue(row.dataset.code);
      const rowTextMatches = elementTextIncludes(row, q);
      let linkMatches = false;
      if (q) {
        linkMatches = Array.from(row.querySelectorAll('.link-title')).some(link => {
          const linkTitle = normalizeFilterValue(link.dataset.title);
          const linkLane = normalizeFilterValue(link.dataset.lane);
          const linkColumn = normalizeFilterValue(link.dataset.column);
          const linkText = normalizeFilterValue(link.textContent);
          return linkTitle.includes(q) || linkLane.includes(q) || linkColumn.includes(q) || linkText.includes(q);
        });
      }
      const show = !q || proj.includes(q) || cli.includes(q) || title.includes(q) || display.includes(q) || code.includes(q) || rowTextMatches || linkMatches;
      row.style.display = show ? '' : 'none';
    });
    updateFilterQueryParam(trimmedValue);
    persistFilterValue(trimmedValue);
    scheduleCalendarHeightRecalc();
  });

  const storedFilterValue = initialFilterValue !== null ? null : loadStoredFilterValue();

  if (filterInput && initialFilterValue !== null) {
    filterInput.value = initialFilterValue;
    filterInput.dispatchEvent(new Event('input'));
  } else if (filterInput && storedFilterValue) {
    filterInput.value = storedFilterValue;
    filterInput.dispatchEvent(new Event('input'));
  }

  function parseISODateParts(value) {
    const match = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(value || '');
    if (!match) return null;
    const year = Number(match[1]);
    const month = Number(match[2]) - 1;
    const day = Number(match[3]);
    if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) return null;
    return { year, month, day };
  }

  function diffInDays(later, earlier) {
    const laterParts = parseISODateParts(later);
    const earlierParts = parseISODateParts(earlier);
    if (!laterParts || !earlierParts) return null;
    const laterUtc = Date.UTC(laterParts.year, laterParts.month, laterParts.day);
    const earlierUtc = Date.UTC(earlierParts.year, earlierParts.month, earlierParts.day);
    return Math.round((laterUtc - earlierUtc) / 86400000);
  }

  function normalizeDateToIso(value) {
    if (!value) return '';
    if (value instanceof Date) {
      return value.toISOString().slice(0, 10);
    }
    const text = `${value}`.trim();
    if (!text) return '';
    const isoMatch = text.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (isoMatch) {
      return `${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}`;
    }
    const euroMatch = text.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
    if (euroMatch) {
      return `${euroMatch[3]}-${euroMatch[2]}-${euroMatch[1]}`;
    }
    return '';
  }

  function formatDueDisplay(value) {
    const parts = parseISODateParts(value);
    if (!parts) return '';
    const day = String(parts.day).padStart(2, '0');
    const month = String(parts.month + 1).padStart(2, '0');
    const year = String(parts.year);
    return `${day}/${month}/${year}`;
  }

  function getProjectEntry(pid) {
    if (!pid || !PROJECT_DATA) return null;
    if (PROJECT_DATA[pid]) return PROJECT_DATA[pid];
    const numericPid = Number(pid);
    if (Number.isFinite(numericPid) && PROJECT_DATA[numericPid]) {
      return PROJECT_DATA[numericPid];
    }
    return null;
  }

  function getProjectObservations(pid) {
    const entry = getProjectEntry(pid);
    if (!entry) return '';
    const value = entry.observations;
    return value === undefined || value === null ? '' : `${value}`;
  }

  function setProjectObservations(pid, value) {
    if (!pid || !PROJECT_DATA) return;
    const entry = getProjectEntry(pid);
    if (entry) {
      entry.observations = value;
      return;
    }
    if (!PROJECT_DATA[pid]) {
      PROJECT_DATA[pid] = { observations: value };
    } else {
      PROJECT_DATA[pid].observations = value;
    }
  }

  function updateObservationsStatus(statusEl, state, message) {
    if (!statusEl) return;
    statusEl.textContent = message || '';
    statusEl.classList.remove('is-saving', 'is-error', 'is-success');
    if (state === 'saving') {
      statusEl.classList.add('is-saving');
    } else if (state === 'error') {
      statusEl.classList.add('is-error');
    } else if (state === 'success') {
      statusEl.classList.add('is-success');
    }
  }

  function syncObservationsCell(cell, pid) {
    if (!cell) return;
    const input = cell.querySelector('.observations-input');
    const text = pid ? getProjectObservations(pid) : '';
    cell.dataset.sort = text.toLocaleLowerCase('es-ES');
    if (input) {
      if (pid) {
        input.disabled = false;
        input.dataset.pid = pid;
      } else {
        input.disabled = true;
        delete input.dataset.pid;
      }
      if (input.value !== text) {
        input.value = text;
      }
    }
  }

  function createObservationsCell(pid) {
    const cell = document.createElement('td');
    cell.className = 'observations-cell';
    const textarea = document.createElement('textarea');
    textarea.className = 'observations-input';
    textarea.placeholder = pid ? 'Añade observaciones' : 'Sin proyecto vinculado';
    if (pid) {
      textarea.dataset.pid = pid;
    } else {
      textarea.disabled = true;
    }
    cell.appendChild(textarea);
    const status = document.createElement('div');
    status.className = 'observations-status';
    status.setAttribute('aria-live', 'polite');
    cell.appendChild(status);
    syncObservationsCell(cell, pid);
    return cell;
  }

  function persistObservationsInput(input) {
    if (!input || input.dataset.obsSaving === '1') return;
    const pid = input.dataset.pid;
    if (!pid) return;
    const text = input.value;
    const current = getProjectObservations(pid);
    const statusEl = input.nextElementSibling && input.nextElementSibling.classList.contains('observations-status')
      ? input.nextElementSibling
      : null;
    if (text === current) {
      updateObservationsStatus(statusEl, '', '');
      return;
    }
    const url = OBS_URL_TEMPLATE.replace('__PID__', encodeURIComponent(pid));
    input.dataset.obsSaving = '1';
    updateObservationsStatus(statusEl, 'saving', 'Guardando...');
    fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({ observations: text })
    })
      .then(resp => {
        if (!resp.ok) {
          return resp.json().catch(() => ({})).then(data => {
            throw new Error(data.error || `Error ${resp.status}`);
          });
        }
        return resp.json().catch(() => ({}));
      })
      .then(() => {
        setProjectObservations(pid, text);
        syncObservationsCell(input.closest('.observations-cell'), pid);
        updateObservationsStatus(statusEl, 'success', 'Guardado');
        setTimeout(() => {
          if (statusEl && statusEl.textContent === 'Guardado') {
            statusEl.textContent = '';
            statusEl.classList.remove('is-success');
          }
        }, 1500);
      })
      .catch(error => {
        updateObservationsStatus(statusEl, 'error', error && error.message ? error.message : 'No se pudo guardar');
      })
      .finally(() => {
        delete input.dataset.obsSaving;
      });
  }

  function initObservationInputs(root = document) {
    if (!root) return;
    const scope = root.querySelectorAll ? root : document;
    scope.querySelectorAll('.observations-input').forEach(input => {
      if (input.dataset.obsInit === '1') return;
      input.dataset.obsInit = '1';
      input.addEventListener('input', () => {
        const statusEl = input.nextElementSibling && input.nextElementSibling.classList.contains('observations-status')
          ? input.nextElementSibling
          : null;
        updateObservationsStatus(statusEl, '', 'Pendiente de guardar');
      });
      input.addEventListener('blur', () => {
        persistObservationsInput(input);
      });
      input.addEventListener('keydown', event => {
        if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
          event.preventDefault();
          input.blur();
        }
      });
    });
  }

  function buildTaskMap() {
    const map = new Map();
    document.querySelectorAll('.pedidos-calendar .task').forEach(task => {
      const title = task.dataset.title;
      if (!title) return;
      if (!map.has(title)) map.set(title, []);
      map.get(title).push(task);
    });
    return map;
  }

  function updateDueWarnings() {
    const taskMap = buildTaskMap();
    const dueLateTitles = new Set();
    document.querySelectorAll('.columna-1 .project-row').forEach(row => {
      const planStart = row.dataset.plan || '';
      const projectDue = row.dataset.due || '';
      row.querySelectorAll('.link-title').forEach(link => {
        const title = link.dataset.title;
        const tasks = taskMap.get(title) || [];
        const calendarDates = tasks
          .map(t => t.dataset.due)
          .filter(Boolean)
          .sort();
        let referenceDate = '';
        if (calendarDates.length) {
          referenceDate = calendarDates[0];
        } else if (projectDue) {
          referenceDate = projectDue;
        }
        let isLate = false;
        if (planStart && referenceDate) {
          const diff = diffInDays(referenceDate, planStart);
          if (diff !== null && Math.abs(diff) <= 3) {
            isLate = true;
            dueLateTitles.add(title);
          }
        }
        link.classList.toggle('due-late', isLate);
      });
    });
    document.querySelectorAll('.pedidos-calendar .task').forEach(task => {
      const title = task.dataset.title;
      task.classList.toggle('due-late', dueLateTitles.has(title));
    });
  }

  let columnResizeState = null;
  let columnResizeCols = [];
  let columnResizeHeaders = [];
  let columnResizeListenersAttached = false;

  function getColumnResizeClientX(event) {
    if (event.touches && event.touches.length) {
      return event.touches[0].clientX;
    }
    if (event.changedTouches && event.changedTouches.length) {
      return event.changedTouches[0].clientX;
    }
    return event.clientX;
  }

  function applyStoredColumnWidths(cols, headers, table) {
    let stored = null;
    try {
      stored = JSON.parse(localStorage.getItem(COLUMN_WIDTHS_KEY));
    } catch (err) {
      stored = null;
    }

    const widths = cols.map((col, index) => {
      const storedWidth = stored && Array.isArray(stored) ? Number(stored[index]) : NaN;
      if (Number.isFinite(storedWidth) && storedWidth > 0) {
        return storedWidth;
      }
      const defaultWidth = Number(col.dataset.defaultWidth);
      if (Number.isFinite(defaultWidth) && defaultWidth > 0) {
        return defaultWidth;
      }
      const header = headers[index];
      if (header) {
        const headerWidth = header.getBoundingClientRect().width;
        if (Number.isFinite(headerWidth) && headerWidth > 0) {
          return headerWidth;
        }
      }
      return null;
    });

    const wrapper = table ? table.parentElement : null;
    const available = wrapper ? wrapper.getBoundingClientRect().width : (table ? table.getBoundingClientRect().width : 0);
    if (available > 0) {
      const total = widths.reduce((sum, value) => sum + (Number.isFinite(value) && value > 0 ? value : 0), 0);
      if (total > 0 && total > available) {
        const minAllowed = 80 * cols.length;
        const target = Math.max(minAllowed, available);
        const scale = target / total;
        widths.forEach((value, index) => {
          if (Number.isFinite(value) && value > 0) {
            widths[index] = Math.max(80, Math.floor(value * scale));
          }
        });
      }
    }

    cols.forEach((col, index) => {
      const width = widths[index];
      if (Number.isFinite(width) && width > 0) {
        col.style.width = `${width}px`;
      } else {
        col.style.removeProperty('width');
      }
    });
  }

  function getColumnWidth(index) {
    const col = columnResizeCols[index];
    if (!col) return 0;
    const width = parseFloat(col.style.width);
    if (Number.isFinite(width) && width > 0) return width;
    const header = columnResizeHeaders[index];
    if (!header) return 0;
    return header.getBoundingClientRect().width;
  }

  function startColumnResize(event, index) {
    const col = columnResizeCols[index];
    const header = columnResizeHeaders[index];
    if (!col || !header) return;
    event.preventDefault();
    const startWidth = getColumnWidth(index);
    columnResizeState = {
      index,
      startX: getColumnResizeClientX(event),
      startWidth,
    };
    document.body.classList.add('columna-1-resizing');
  }

  function handleColumnResizeMove(event) {
    if (!columnResizeState) return;
    event.preventDefault();
    const currentX = getColumnResizeClientX(event);
    const delta = currentX - columnResizeState.startX;
    const newWidth = Math.max(80, columnResizeState.startWidth + delta);
    const col = columnResizeCols[columnResizeState.index];
    if (col) {
      col.style.width = `${newWidth}px`;
    }
  }

  function finishColumnResize() {
    if (!columnResizeState) return;
    document.body.classList.remove('columna-1-resizing');
    const widths = columnResizeCols.map((col, index) => {
      const width = parseFloat(col.style.width);
      if (Number.isFinite(width) && width > 0) return width;
      const header = columnResizeHeaders[index];
      return header ? header.getBoundingClientRect().width : null;
    });
    localStorage.setItem(COLUMN_WIDTHS_KEY, JSON.stringify(widths));
    columnResizeState = null;
  }

  function initColumnResizing() {
    const table = document.querySelector('.columna-1-table');
    if (!table) return;
    const colgroup = table.querySelector('colgroup');
    if (!colgroup) return;

    columnResizeCols = Array.from(colgroup.children);
    columnResizeHeaders = Array.from(table.querySelectorAll('thead th'));

    applyStoredColumnWidths(columnResizeCols, columnResizeHeaders, table);

    columnResizeHeaders.forEach((th, index) => {
      if (th.querySelector('.col-resize-handle')) return;
      const handle = document.createElement('span');
      handle.className = 'col-resize-handle';
      handle.addEventListener('mousedown', event => startColumnResize(event, index));
      handle.addEventListener('touchstart', event => startColumnResize(event, index), { passive: false });
      th.appendChild(handle);
    });

    if (!columnResizeListenersAttached) {
      document.addEventListener('mousemove', handleColumnResizeMove);
      document.addEventListener('mouseup', finishColumnResize);
      document.addEventListener('touchmove', handleColumnResizeMove, { passive: false });
      document.addEventListener('touchend', finishColumnResize);
      document.addEventListener('touchcancel', finishColumnResize);
      columnResizeListenersAttached = true;
    }
  }

  let currentHighlightState = null;
  let currentHighlightKey = null;

  function normalizeSelection(selection) {
    if (!selection) return null;
    if (typeof selection === 'string') {
      selection = { titles: [selection] };
    } else if (Array.isArray(selection)) {
      selection = { titles: selection };
    } else {
      selection = { ...selection };
    }

    const titles = [];
    if (selection.title) titles.push(selection.title);
    if (Array.isArray(selection.titles)) titles.push(...selection.titles);
    const normTitles = new Set();
    titles.forEach(value => {
      const key = norm(value);
      if (key) normTitles.add(key);
    });
    if (!normTitles.size) return null;

    let laneKeys = null;
    if (selection.lane) {
      const laneKey = norm(selection.lane);
      if (laneKey) {
        laneKeys = new Set([laneKey]);
      }
    }
    if (selection.lanes) {
      if (!laneKeys) laneKeys = new Set();
      for (const lane of selection.lanes) {
        const laneKey = norm(lane);
        if (laneKey) laneKeys.add(laneKey);
      }
      if (!laneKeys.size) laneKeys = null;
    }

    const key = JSON.stringify({
      titles: Array.from(normTitles).sort(),
      lanes: laneKeys ? Array.from(laneKeys).sort() : null,
    });

    return { titleKeys: normTitles, laneKeys, key };
  }

  function applyHighlight(state) {
    const wrapper = document.querySelector('.pedidos-wrapper');
    const tasks = document.querySelectorAll('.pedidos-wrapper .task');
    const links = document.querySelectorAll('.columna-1 .link-title');
    const projectRows = document.querySelectorAll('.columna-1 .project-row');
    tasks.forEach(t => {
      t.classList.remove('highlight');
      t.classList.remove('dimmed');
    });
    links.forEach(l => {
      l.classList.remove('highlight');
      l.classList.remove('dimmed');
    });
    projectRows.forEach(row => {
      row.classList.remove('highlight');
      row.classList.remove('dimmed');
    });
    if (wrapper) {
      wrapper.classList.toggle('highlight-active', !!state);
    }
    if (!state) return;

    const highlightedRows = new Set();

    tasks.forEach(t => {
      const titleKey = norm(t.dataset.title);
      const laneKey = norm(t.dataset.lane);
      if (state.titleKeys.has(titleKey) && (!state.laneKeys || state.laneKeys.has(laneKey))) {
        t.classList.add('highlight');
      } else {
        t.classList.add('dimmed');
      }
    });
    links.forEach(l => {
      const titleKey = norm(l.dataset.title);
      const laneKey = norm(l.dataset.lane);
      if (state.titleKeys.has(titleKey) && (!state.laneKeys || state.laneKeys.has(laneKey))) {
        l.classList.add('highlight');
        const row = l.closest('.project-row');
        if (row) highlightedRows.add(row);
      } else {
        l.classList.add('dimmed');
      }
    });
    projectRows.forEach(row => {
      if (highlightedRows.has(row)) {
        row.classList.add('highlight');
      } else {
        row.classList.add('dimmed');
      }
    });
  }

  function clearHighlight() {
    applyHighlight(null);
    currentHighlightState = null;
    currentHighlightKey = null;
    clearStartDayHighlight();
  }

  function reapplyHighlight() {
    if (currentHighlightState) {
      applyHighlight(currentHighlightState);
    }
  }

  function toggleHighlight(selection) {
    const state = normalizeSelection(selection);
    if (!state) {
      clearHighlight();
      return;
    }
    if (currentHighlightKey && state.key === currentHighlightKey) {
      clearHighlight();
      return;
    }
    applyHighlight(state);
    currentHighlightState = state;
    currentHighlightKey = state.key;
  }

  function attachHighlightHandlers() {
    document.querySelectorAll('.pedidos-calendar').forEach((calendar) => {
      calendar.addEventListener('click', e => {
        const t = e.target.closest('.task');
        if (!t) return;
        const title = t.dataset.title;
        if (!title) return;
        toggleHighlight({ titles: [title] });
        if (currentHighlightState && t.dataset.pid) {
          highlightProjectStartByPid(t.dataset.pid);
        } else if (!currentHighlightState) {
          clearStartDayHighlight();
        }
      });
    });
    const column = document.querySelector('.columna-1');
    if (column) {
      column.addEventListener('click', e => {
        const el = e.target.closest('.link-title');
        if (!el) return;
        const title = el.dataset.title;
        if (!title) return;
        const row = el.closest('.project-row');
        toggleHighlight({ titles: [title] });
        if (currentHighlightState && row) {
          highlightProjectStartByRow(row);
        } else if (!currentHighlightState) {
          clearStartDayHighlight();
        }
      });
    }
  }

  attachHighlightHandlers();
  updateDueWarnings();
  initColumna1Sorting();
  initColumnResizing();

  const projectList = document.querySelector('.columna-1');
  document.querySelectorAll('.columna-1 .project-row').forEach(row => {
    const pid = resolveRowPid(row);
    const cell = row.querySelector('.observations-cell');
    if (cell) syncObservationsCell(cell, pid);
  });
  initObservationInputs();
  if (projectList) {
    projectList.addEventListener('click', e => {
      const trigger = e.target.closest('.proj-code, .proj-title');
      if (!trigger) return;
      const row = trigger.closest('.project-row');
      if (!row) return;
      if (trigger.classList.contains('proj-title')) {
        const matchingTitles = Array.from(row.querySelectorAll('.link-title'))
          .filter(link => norm(link.dataset.lane) === 'seguimiento compras')
          .map(link => link.dataset.title)
          .filter(Boolean);
        if (matchingTitles.length) {
          toggleHighlight({ titles: matchingTitles, lane: 'Seguimiento compras' });
        } else {
          clearHighlight();
        }
      }
      highlightProjectStartByRow(row);
      const pid = resolveRowPid(row);
      if (!pid || !PROJECT_DATA[pid]) return;
      e.stopPropagation();
      const rect = trigger.getBoundingClientRect();
      const projectName = row.dataset.project || '';
      openPhasePopup({ pid, project: projectName }, rect);
    });
  }

  if (initialHighlightPid) {
    const highlightRow = Array.from(document.querySelectorAll('.columna-1 .project-row')).find(row => row.dataset.pid === initialHighlightPid);
    if (highlightRow) {
      const highlightTitles = Array.from(highlightRow.querySelectorAll('.link-title')).map(link => link.dataset.title).filter(Boolean);
      if (highlightTitles.length) {
        toggleHighlight({ titles: highlightTitles });
      } else {
        highlightRow.classList.add('highlight');
      }
      highlightProjectStartByRow(highlightRow);
      highlightRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
    } else {
      highlightProjectStartByPid(initialHighlightPid);
    }
    const highlightTasks = Array.from(document.querySelectorAll(`.pedidos-calendar .task[data-pid='${initialHighlightPid}']`));
    if (highlightTasks.length) {
      highlightTasks[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    const updatedUrl = new URL(window.location.href);
    updatedUrl.searchParams.delete('highlight');
    history.replaceState(null, '', updatedUrl);
  }

  const source = new EventSource("{{ url_for('event_stream') }}");
  source.onmessage = () => {
    fetch("{{ url_for('project_links_api') }}")
      .then(r => r.json())
      .then(items => {
        const container = document.querySelector('.columna-1-content');
        if (!container) return;
        container.querySelectorAll('.project-row').forEach(r => r.remove());
        const infoTitleEl = document.getElementById('columna-1-info-title');
        if (infoTitleEl) {
          const infoNames = Array.from(new Set(items.map(item => (item.board || '').trim()).filter(Boolean)));
          if (infoNames.length) {
            const newTitle = infoNames.join(' / ');
            infoTitleEl.textContent = newTitle;
            infoTitleEl.dataset.defaultTitle = newTitle;
          } else {
            infoTitleEl.textContent = infoTitleEl.dataset.defaultTitle || '';
          }
        }

        items.forEach(item => {
          const row = document.createElement('tr');
          row.className = 'project-row';
          row.dataset.pid = item.pid || '';
          const projectValue = (item.project || item.title || '').trim();
          row.dataset.project = projectValue;
          const fullTitle = (item.title || '').trim();
          const resolvedTitle = fullTitle || projectValue;
          row.dataset.title = resolvedTitle;
          row.dataset.client = item.client || '';
          const planValueRaw = item.plan_start || item.montar_start || '';
          const planValue = planValueRaw ? String(planValueRaw).trim() : '';
          row.dataset.plan = planValue;
          row.dataset.due = item.due || '';
          const display = (item.display_title || resolvedTitle || '').trim();
          const code = (item.custom_card_id || '').trim();
          const dueDisplay = formatDueDisplay(item.due);
          const startDisplay = formatDueDisplay(planValue);
          row.dataset.display = display;
          row.dataset.code = code;

          const titleCell = document.createElement('td');
          titleCell.className = 'proj-title-cell';
          const titleSortValue = (resolvedTitle || projectValue || '').toLocaleLowerCase('es-ES');
          titleCell.dataset.sort = titleSortValue;
          if (code) {
            const codeSpan = document.createElement('span');
            codeSpan.className = 'proj-code proj-code-badge';
            codeSpan.dataset.project = projectValue;
            codeSpan.dataset.code = code;
            codeSpan.textContent = code;
            titleCell.appendChild(codeSpan);
          }
          const titleStrong = document.createElement('strong');
          titleStrong.className = 'proj-title';
          titleStrong.dataset.project = projectValue;
          titleStrong.dataset.code = code;
          titleStrong.textContent = resolvedTitle;
          titleCell.appendChild(titleStrong);
          row.appendChild(titleCell);

          const dueCell = document.createElement('td');
          dueCell.className = 'due-cell';
          dueCell.dataset.sortType = 'date';
          dueCell.dataset.sort = item.due ? String(item.due).trim() : '';
          if (dueDisplay) {
            const dueSpan = document.createElement('span');
            dueSpan.className = 'proj-due';
            dueSpan.textContent = dueDisplay;
            dueCell.appendChild(dueSpan);
          }
          row.appendChild(dueCell);

          const startCell = document.createElement('td');
          startCell.className = 'start-cell';
          startCell.dataset.sortType = 'date';
          startCell.dataset.sort = planValue;
          if (startDisplay) {
            const startSpan = document.createElement('span');
            startSpan.className = 'proj-start';
            startSpan.textContent = startDisplay;
            startCell.appendChild(startSpan);
          }
          row.appendChild(startCell);

          const orderCell = document.createElement('td');
          orderCell.className = 'order-date-cell';
          orderCell.dataset.sortType = 'date';

          const countCell = document.createElement('td');
          countCell.className = 'order-count-cell';
          countCell.dataset.sortType = 'number';

          const linksCell = document.createElement('td');
          linksCell.className = 'links-cell';
          linksCell.dataset.sort = '';
          const linkDetails = Array.isArray(item.link_details) ? item.link_details : [];
          const links = Array.isArray(item.links) ? item.links : [];
          let earliestOrder = '';
          let firstCount = '';
          let firstLinkSort = '';
          links.forEach((link, idx) => {
            const detail = linkDetails[idx] || {};
            const orderDiv = document.createElement('div');
            orderDiv.className = 'order-date-entry';
            const orderValue = detail && detail.order_date ? String(detail.order_date).trim() : '';
            const orderRaw = detail && detail.order_date_raw ? String(detail.order_date_raw).trim() : '';
            if (orderValue) {
              orderDiv.dataset.order = orderValue;
              orderDiv.textContent = formatDueDisplay(orderValue);
              if (!orderDiv.textContent) orderDiv.textContent = orderValue;
              if (!earliestOrder || orderValue < earliestOrder) {
                earliestOrder = orderValue;
              }
            } else if (orderRaw) {
              orderDiv.textContent = orderRaw;
            } else {
              orderDiv.appendChild(document.createTextNode('\u00a0'));
            }
            orderCell.appendChild(orderDiv);

            const countDiv = document.createElement('div');
            countDiv.className = 'order-count-entry';
            const daysValue = detail && detail.order_days;
            const daysNumber = typeof daysValue === 'number' ? daysValue : Number(daysValue);
            if (Number.isFinite(daysNumber)) {
              countDiv.dataset.days = `${daysNumber}`;
              countDiv.textContent = `${daysNumber}`;
              if (!firstCount) {
                firstCount = `${daysNumber}`;
              }
            } else {
              countDiv.appendChild(document.createTextNode('\u00a0'));
            }
            countCell.appendChild(countDiv);

            const linkDiv = document.createElement('div');
            linkDiv.className = 'link-title';
            linkDiv.dataset.title = link;
            const laneValue = detail && detail.lane ? detail.lane : '';
            const columnValue = detail && detail.column ? detail.column : '';
            let tooltip = columnValue;
            if (!tooltip && laneValue) {
              tooltip = laneValue;
            } else if (tooltip && laneValue && laneValue !== columnValue) {
              tooltip = `${tooltip} · ${laneValue}`;
            }
            linkDiv.dataset.lane = laneValue;
            linkDiv.dataset.column = columnValue;
            if (tooltip) linkDiv.title = tooltip;
            linkDiv.textContent = link;
            if (!firstLinkSort && link) {
              firstLinkSort = link.toLocaleLowerCase('es-ES');
            }
            linksCell.appendChild(linkDiv);
          });
          orderCell.dataset.sort = earliestOrder;
          countCell.dataset.sort = firstCount;
          linksCell.dataset.sort = firstLinkSort;
          row.appendChild(orderCell);
          row.appendChild(countCell);
          row.appendChild(linksCell);

          const resolvedPid = resolveRowPid(row);
          const observationsCell = createObservationsCell(resolvedPid);
          row.appendChild(observationsCell);
          initObservationInputs(row);
          container.appendChild(row);
        });
        const columnaTable = document.querySelector('.columna-1-table');
        reapplyColumna1Sort(columnaTable);
        filterInput.dispatchEvent(new Event('input'));
        reapplyHighlight();
        updateDueWarnings();
        scheduleCalendarHeightRecalc();
      });
  };
});
</script>
{% endblock %}
