{% extends 'base.html' %}
{% block content %}
<form id="quick-card-form" class="quick-card-form">
  <label class="quick-card-field" for="quick-card-date">
    <span>Fecha</span>
    <input type="date" id="quick-card-date" name="date" required>
  </label>
  <label class="quick-card-field" for="quick-card-title">
    <span>Título</span>
    <input type="text" id="quick-card-title" name="title" placeholder="Título del pedido" required>
  </label>
  <button type="submit">Crear tarjeta</button>
</form>
<input type="text" id="filter-input" placeholder="Filtrar por título o cliente">
{% set calendar_definitions = [
  {'key': 'pedidos', 'title': 'Calendario pedidos', 'weeks': weeks, 'unconfirmed': unconfirmed},
  {'key': 'subcontrataciones', 'title': 'Calendario subcontrataciones', 'weeks': subcontr_weeks, 'unconfirmed': subcontr_unconfirmed}
] %}
<div class="pedidos-wrapper">
  <div class="pedidos-calendar-stack">
  {% for calendar in calendar_definitions %}
    <h2>{{ calendar.title }}</h2>
    {% set week_count = calendar.weeks|length %}
    {% if week_count < 1 %}
      {% set week_count = 1 %}
    {% endif %}
    <div class="pedidos-calendar-container" data-calendar="{{ calendar.key }}">
      <table class="pedidos-calendar" data-calendar="{{ calendar.key }}">
        <thead>
        <tr>
            <th class="week-header">Semana</th>
            <th class="day-header">Lun</th>
            <th class="day-header">Mar</th>
            <th class="day-header">Mié</th>
            <th class="day-header">Jue</th>
            <th class="day-header">Vie</th>
            <th rowspan="{{ week_count + 1 }}" class="unconfirmed-header">Sin fecha de entrega confirmada</th>
        </tr>
        </thead>
        <tbody>
        {% for week in calendar.weeks %}
        <tr>
            <td class="week-label">Semana {{ week.number }}</td>
            {% for d in week.days %}
            <td data-date="{{ d.date.isoformat() }}" class="day-cell{% if d.date == today %} today{% endif %}">
                {% if d.month %}<div class="month-divider">{{ d.month }}</div>{% endif %}
                <div class="day-number">{{ d.day }}</div>
                {% for t in d.tasks %}
                <div class="task{% if t.get('simulated') %} simulated{% endif %}" draggable="true"
                     data-pid="{{ t.get('pid') or '' }}"
                     data-phase="{{ t.get('phase') or '' }}"
                     data-day="{{ d.date.isoformat() }}"
                     data-worker="{{ t.get('worker') or '' }}"
                     data-cid="{{ t.get('cid') or '' }}"
                     data-project="{{ t.project }}"
                     data-title="{{ t.project }}"
                     data-code="{{ t.get('custom_card_id') or '' }}"
                     data-client="{{ t.get('client') or '' }}"
                     data-due="{{ d.date.isoformat() }}"
                     data-lane="{{ t.get('lane') or '' }}"
                     {% if t.get('part') is not none %}data-part="{{ t.get('part') }}"{% endif %}
                     style="border-color: {{ t.get('color', '#999999') }};">
                    <span class="task-main">{{ t.project }}</span>
                    {% if t.hours %}
                    <span class="task-hours">{% if t.auto %}<span class="auto-hour">{{ t.hours }}h</span>{% else %}{{ t.hours }}h{% endif %}</span>
                    {% endif %}
                </div>
                {% endfor %}
            </td>
            {% endfor %}
            {% if loop.first %}
            <td class="unconfirmed" rowspan="{{ week_count }}">
                {% for t in calendar.unconfirmed %}
                  <div class="task{% if t.get('simulated') %} simulated{% endif %}" draggable="true"
                       data-pid="{{ t.get('pid') or '' }}"
                       data-phase="{{ t.get('phase') or '' }}"
                       data-worker="{{ t.get('worker') or '' }}"
                       data-cid="{{ t.get('cid') or '' }}"
                       data-project="{{ t.project }}"
                       data-title="{{ t.project }}"
                       data-code="{{ t.get('custom_card_id') or '' }}"
                       data-client="{{ t.get('client') or '' }}"
                       data-lane="{{ t.get('lane') or '' }}"
                       style="border-color: {{ t.get('color', '#999999') }};">
                    <span class="task-main">{{ t.project }}</span>
                    {% if t.prev_date %}<span class="task-date">({{ t.prev_date }})</span>{% endif %}
                    {% if t.hours %}<span class="task-hours">{{ t.hours }}h</span>{% endif %}
                </div>
                {% endfor %}
            </td>
            {% endif %}
        </tr>
        {% endfor %}
        </tbody>
      </table>
    </div>
  {% endfor %}
  </div>
<div class="columna-1">
    <div class="columna-1-title" id="columna-1-info-title" data-default-title="{{ project_info_title or '' }}">{{ project_info_title or '' }}</div>
    <h3>Columna 1</h3>
    <div class="columna-1-table-wrapper">
      <table class="columna-1-table">
        <colgroup>
          <col data-col-key="project" data-default-width="380">
          <col data-col-key="due" data-default-width="140">
          <col data-col-key="start" data-default-width="170">
          <col data-col-key="order-date" data-default-width="160">
          <col data-col-key="order-count" data-default-width="120">
          <col data-col-key="links" data-default-width="360">
          <col data-col-key="observations" data-default-width="320">
        </colgroup>
        <thead>
          <tr>
            <th scope="col">Proyecto</th>
            <th scope="col">Entrega (Fecha tope)</th>
            <th scope="col">Inicio planificado</th>
            <th scope="col">Fecha pedido</th>
            <th scope="col">Conteo</th>
            <th scope="col">Fases</th>
            <th scope="col" class="observations-header">Observaciones</th>
          </tr>
        </thead>
        <tbody class="columna-1-content">
        {% for item in project_links %}
            {% set project_value = (item.project or item.title)|trim %}
            {% set title_value = (item.title or item.project)|trim %}
            {% set code_value = (item.custom_card_id or '')|trim %}
            {% set plan_value = item.plan_start or item.montar_start %}
            {% set due_display = (item.due|format_due_date)|trim %}
            {% set start_display = (plan_value|format_due_date)|trim %}
            {% set details = item.link_details or [] %}
            {% set pid_value = item.pid|string if item.pid is not none else '' %}
            {% set project_entry = project_data.get(pid_value) or project_data.get(item.pid) %}
            {% set obs_value = project_entry.observations if project_entry and project_entry.observations is not none else '' %}
          <tr class="project-row"
              data-pid="{{ item.pid or '' }}"
              data-project="{{ project_value }}"
              data-title="{{ title_value }}"
              data-display="{{ (item.display_title or item.title or item.project)|trim }}"
              data-client="{{ item.client }}"
              data-code="{{ code_value }}"
              data-due="{{ item.due or '' }}"
              data-plan="{{ plan_value or '' }}">
            <td class="proj-title-cell" data-sort="{{ (title_value or project_value)|default('', true)|lower }}">
              {% if code_value %}
              <span class="proj-code proj-code-badge"
                    data-project="{{ project_value }}"
                    data-code="{{ code_value }}">{{ code_value }}</span>
              {% endif %}
              <strong class="proj-title"
                      data-project="{{ project_value }}"
                      data-code="{{ code_value }}">{{ title_value or project_value }}</strong>
            </td>
            <td class="due-cell" data-sort="{{ item.due or '' }}" data-sort-type="date">
            {% if due_display %}
              <span class="proj-due">{{ due_display }}</span>
            {% endif %}
            </td>
            <td class="start-cell" data-sort="{{ plan_value or '' }}" data-sort-type="date">
            {% if start_display %}
              <span class="proj-start">{{ start_display }}</span>
            {% endif %}
            </td>
            {% set order_meta = namespace(first=None) %}
            {% set count_meta = namespace(value=None) %}
            {% set link_meta = namespace(value=None) %}
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set order_value = detail.order_date %}
                {% if order_value %}
                    {% if order_meta.first is none or order_value < order_meta.first %}
                        {% set order_meta.first = order_value %}
                    {% endif %}
                {% endif %}
                {% set order_days = detail.order_days %}
                {% if order_days is not none and count_meta.value is none %}
                    {% set count_meta.value = order_days %}
                {% endif %}
                {% if link_meta.value is none and link %}
                    {% set link_meta.value = link|lower %}
                {% endif %}
            {% endfor %}
            <td class="order-date-cell" data-sort="{{ order_meta.first or '' }}" data-sort-type="date">
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set order_value = detail.order_date %}
                {% set order_raw = detail.order_date_raw %}
              <div class="order-date-entry"
                   {% if order_value %}data-order="{{ order_value }}"{% endif %}>
                {% if order_value %}
                  {{ order_value|format_due_date }}
                {% elif order_raw %}
                  {{ order_raw }}
                {% else %}
                  &nbsp;
                {% endif %}
              </div>
            {% endfor %}
            </td>
            <td class="order-count-cell" data-sort="{{ count_meta.value if count_meta.value is not none else '' }}" data-sort-type="number">
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set order_days = detail.order_days %}
              <div class="order-count-entry"
                   {% if order_days is not none %}data-days="{{ order_days }}"{% endif %}>
                {% if order_days is not none %}
                  {{ order_days }}
                {% else %}
                  &nbsp;
                {% endif %}
              </div>
            {% endfor %}
            </td>
            <td class="links-cell" data-sort="{{ link_meta.value or '' }}">
            {% for link in item.links %}
                {% set detail = details[loop.index0] if loop.index0 < details|length else {} %}
                {% set column_value = detail.column|default('', true) %}
                {% set lane_value = detail.lane|default('', true) %}
                {% set tooltip = column_value %}
                {% if not tooltip and lane_value %}
                  {% set tooltip = lane_value %}
                {% elif tooltip and lane_value and lane_value != column_value %}
                  {% set tooltip = tooltip ~ ' · ' ~ lane_value %}
                {% endif %}
              <div class="link-title"
                   data-title="{{ link }}"
                   data-lane="{{ lane_value }}"
                   data-column="{{ column_value }}"
                   {% if tooltip %}title="{{ tooltip }}"{% endif %}>{{ link }}</div>
            {% endfor %}
            </td>
            <td class="observations-cell" data-sort="{{ obs_value|lower }}">
              {% if pid_value %}
              <textarea class="observations-input" data-pid="{{ pid_value }}" placeholder="Añade observaciones">{{ obs_value }}</textarea>
              <div class="observations-status" aria-live="polite"></div>
              {% else %}
              <textarea class="observations-input" disabled placeholder="Sin proyecto vinculado"></textarea>
              <div class="observations-status" aria-live="polite"></div>
              {% endif %}
            </td>
          </tr>
        {% endfor %}
        </tbody>
      </table>
    </div>
</div>
</div>
<div id="info-popup" class="info-popup"></div>
<div id="split-modal" class="conflict-modal">
  <div class="conflict-content">
    <form id="split-form">
      <div id="split-total-hours" class="split-total-hours"></div>
      <div id="split-parts-container" class="split-parts-container"></div>
      <button type="button" id="split-add-part" class="split-add-part" title="Añadir parte">+</button>
      <div class="split-actions">
        <button type="submit">Aceptar</button>
        <button type="button" id="split-cancel">Cancelar</button>
      </div>
    </form>
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const PROJECT_DATA = {{ project_data|tojson }};
  const START_DATA = {{ start_map|tojson }};
  const PHASES = {{ phases|tojson }};
  const STATIC_URL = "{{ url_for('static', filename='') }}";
  const MOVE_URL = "{{ url_for('move_phase') }}";
  const DELETE_URL = "{{ url_for('delete_phase') }}";
  const START_URL = "{{ url_for('update_phase_start') }}";
  const SPLIT_URL = "";
  const UNSPLIT_URL = "";
  const TABLE_COLLATOR = typeof Intl !== 'undefined'
    ? new Intl.Collator('es', { sensitivity: 'base', numeric: true })
    : null;
  const PHASE_HOURS_URL = "{{ url_for('update_phase_hours') }}";
  const OBS_URL_TEMPLATE = "{{ url_for('update_observations', pid='__PID__') }}";
  const COMPLETE_URL = "{{ url_for('complete') }}";
  const LAST_KEY = 'lastMoved';
  const SCROLL_KEY2 = 'scrollDate';
  const COLUMN_WIDTHS_KEY = 'columna1ColumnWidths';
  const popup = document.getElementById('info-popup');
  const splitModal = document.getElementById('split-modal');
  const splitForm = document.getElementById('split-form');
  const splitPartsContainer = document.getElementById('split-parts-container');
  const splitAddPartButton = document.getElementById('split-add-part');
  const splitTotalDisplay = document.getElementById('split-total-hours');
  const splitCancel = document.getElementById('split-cancel');
  let splitRemainderInput = null;
  let startDayHighlightCell = null;
  const SPLIT_WORKDAY_HOURS = 8;
  const SPLIT_ORDINAL_WORDS = ['primera', 'segunda', 'tercera', 'cuarta', 'quinta', 'sexta', 'séptima', 'octava', 'novena', 'décima'];
  const pageParams = new URLSearchParams(window.location.search);
  const initialFilterValue = pageParams.get('filter');
  const initialHighlightPid = pageParams.get('highlight');
  const START_DAY_HIGHLIGHT_CLASS = 'start-day-highlight';
  const quickCardForm = document.getElementById('quick-card-form');
  const quickCardDate = document.getElementById('quick-card-date');
  const quickCardTitle = document.getElementById('quick-card-title');
  const QUICK_CARD_STORAGE_KEY = 'pedidosQuickCards';
  const QUICK_CARD_ORDER_STORAGE_KEY = 'pedidosQuickCardOrder';
  const FILTER_STORAGE_KEY = 'pedidosCalendarFilter';
  const UNCONFIRMED_ORDER_KEY = '__unconfirmed__';
  const quickCardStorageEnabled = (() => {
    try {
      if (typeof window === 'undefined' || !window.localStorage) {
        return false;
      }
      const probeKey = '__quickCardProbe__';
      window.localStorage.setItem(probeKey, '1');
      window.localStorage.removeItem(probeKey);
      return true;
    } catch (error) {
      return false;
    }
  })();
  let quickCardStore = [];
  let taskOrderMap = {};

  function loadTaskOrderFromStorage() {
    if (!quickCardStorageEnabled) {
      return {};
    }
    try {
      const raw = window.localStorage.getItem(QUICK_CARD_ORDER_STORAGE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return {};
      return Object.keys(parsed).reduce((acc, key) => {
        const value = parsed[key];
        if (Array.isArray(value)) {
          acc[key] = value.filter(id => typeof id === 'string' && id);
        }
        return acc;
      }, {});
    } catch (error) {
      return {};
    }
  }

  function persistTaskOrder() {
    if (!quickCardStorageEnabled) {
      return;
    }
    try {
      window.localStorage.setItem(QUICK_CARD_ORDER_STORAGE_KEY, JSON.stringify(taskOrderMap));
    } catch (error) {
      // Ignore persistence issues
    }
  }

  function removeTaskIdFromOrder(id) {
    if (!id) return;
    let changed = false;
    Object.keys(taskOrderMap).forEach((key) => {
      const current = taskOrderMap[key];
      if (!Array.isArray(current)) {
        return;
      }
      const filtered = current.filter(value => value !== id);
      if (filtered.length !== current.length) {
        changed = true;
        if (filtered.length) {
          taskOrderMap[key] = filtered;
        } else {
          delete taskOrderMap[key];
        }
      }
    });
    if (changed) {
      persistTaskOrder();
    }
  }

  function pruneTaskOrder(validQuickCardIds) {
    if (validQuickCardIds && !(validQuickCardIds instanceof Set)) {
      return;
    }
    let changed = false;
    Object.keys(taskOrderMap).forEach((key) => {
      const current = taskOrderMap[key];
      if (!Array.isArray(current)) {
        delete taskOrderMap[key];
        changed = true;
        return;
      }
      const filtered = current.filter(id => {
        if (!validQuickCardIds) {
          return true;
        }
        if (id.startsWith('phase:') || id.startsWith('cid:')) {
          return true;
        }
        return validQuickCardIds.has(id);
      });
      if (!filtered.length) {
        if (current.length) {
          delete taskOrderMap[key];
          changed = true;
        }
        return;
      }
      if (filtered.length !== current.length) {
        taskOrderMap[key] = filtered;
        changed = true;
      }
    });
    if (changed) {
      persistTaskOrder();
    }
  }

  function getCellStorageKey(cell) {
    if (!cell) {
      return null;
    }
    if (cell.dataset && cell.dataset.date) {
      return cell.dataset.date;
    }
    if (cell.classList && cell.classList.contains('unconfirmed')) {
      return UNCONFIRMED_ORDER_KEY;
    }
    return null;
  }

  function getTaskStorageId(element) {
    if (!element || !element.dataset) {
      return null;
    }
    if (element.dataset.quickCardId) {
      return element.dataset.quickCardId;
    }
    if (element.dataset.cid) {
      return `cid:${element.dataset.cid}`;
    }
    if (element.dataset.pid && element.dataset.phase) {
      const partValue = normalizePartValue(element.dataset.part);
      return `phase:${element.dataset.pid}:${element.dataset.phase}:${partValue}`;
    }
    return null;
  }

  function getCellTaskIds(cell) {
    if (!cell) {
      return [];
    }
    return Array.from(cell.querySelectorAll('.task')).map(getTaskStorageId).filter(Boolean);
  }

  function captureTaskOrderForCell(cell) {
    const key = getCellStorageKey(cell);
    if (!key) {
      return;
    }
    const ids = getCellTaskIds(cell);
    if (!ids.length) {
      if (taskOrderMap[key]) {
        delete taskOrderMap[key];
        persistTaskOrder();
      }
      return;
    }
    const prev = taskOrderMap[key] || [];
    const changed = prev.length !== ids.length || ids.some((value, index) => prev[index] !== value);
    if (!changed) {
      return;
    }
    taskOrderMap[key] = ids;
    persistTaskOrder();
  }

  function applyTaskOrderToCell(cell) {
    const key = getCellStorageKey(cell);
    if (!key) {
      return;
    }
    const ids = taskOrderMap[key];
    if (!Array.isArray(ids) || !ids.length) {
      return;
    }
    const tasks = Array.from(cell.querySelectorAll('.task'));
    if (!tasks.length) {
      return;
    }
    const byId = new Map();
    tasks.forEach(el => {
      const storageId = getTaskStorageId(el);
      if (storageId) {
        byId.set(storageId, el);
      }
    });
    ids.forEach(id => {
      const element = byId.get(id);
      if (element) {
        cell.appendChild(element);
        byId.delete(id);
      }
    });
    byId.forEach((element) => {
      cell.appendChild(element);
    });
    const finalIds = getCellTaskIds(cell);
    const stored = taskOrderMap[key] || [];
    const changed = finalIds.length
      ? (stored.length !== finalIds.length || finalIds.some((value, index) => stored[index] !== value))
      : stored.length > 0;
    if (changed) {
      if (finalIds.length) {
        taskOrderMap[key] = finalIds;
      } else {
        delete taskOrderMap[key];
      }
      persistTaskOrder();
    }
  }

  function applyStoredOrderToCalendar() {
    document.querySelectorAll('.pedidos-calendar td.day-cell[data-date], .pedidos-calendar td.unconfirmed').forEach(cell => {
      applyTaskOrderToCell(cell);
    });
  }

  function loadQuickCardsFromStorage() {
    if (!quickCardStorageEnabled) {
      return [];
    }
    try {
      const raw = window.localStorage.getItem(QUICK_CARD_STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed
        .map(entry => {
          if (!entry || typeof entry !== 'object') return null;
          const id = typeof entry.id === 'string' ? entry.id : null;
          const date = typeof entry.date === 'string' ? entry.date : null;
          const title = typeof entry.title === 'string' ? entry.title : null;
          if (!id || !date || !title) return null;
          return { id, date, title };
        })
        .filter(Boolean);
    } catch (error) {
      return [];
    }
  }

  function persistQuickCards() {
    if (!quickCardStorageEnabled) {
      return;
    }
    try {
      window.localStorage.setItem(QUICK_CARD_STORAGE_KEY, JSON.stringify(quickCardStore));
    } catch (error) {
      // Ignore persistence issues (e.g. quota exceeded)
    }
  }

  function updateQuickCardStoreDate(cardId, date) {
    if (!cardId) {
      return;
    }
    let changed = false;
    quickCardStore = quickCardStore.map(card => {
      if (card.id === cardId) {
        if (card.date !== date) {
          changed = true;
          return { id: card.id, date, title: card.title };
        }
      }
      return card;
    });
    if (changed) {
      persistQuickCards();
    }
  }

  function generateQuickCardId() {
    return `qc_${Date.now().toString(36)}${Math.random().toString(36).slice(2, 8)}`;
  }

  function hideAllQuickCardDeleteButtons(except = null) {
    document.querySelectorAll('.task.quick-card.quick-card-show-delete').forEach(card => {
      if (except && card === except) {
        return;
      }
      card.classList.remove('quick-card-show-delete');
    });
  }

  function removeQuickCardById(id) {
    if (!id) return;
    const nextStore = quickCardStore.filter(card => card.id !== id);
    if (nextStore.length !== quickCardStore.length) {
      quickCardStore = nextStore;
      persistQuickCards();
      removeTaskIdFromOrder(id);
    }
  }

  function createQuickCardElement(card) {
    const element = document.createElement('div');
    element.className = 'task quick-card';
    element.setAttribute('draggable', 'true');
    element.dataset.quickCardId = card.id;
    element.dataset.project = card.title;
    element.dataset.title = card.title;
    element.dataset.client = '';
    element.dataset.code = '';
    if (card.date === UNCONFIRMED_ORDER_KEY) {
      element.dataset.day = '';
      element.dataset.due = '';
    } else {
      element.dataset.day = card.date;
      element.dataset.due = card.date;
    }

    const main = document.createElement('span');
    main.className = 'task-main';
    main.textContent = card.title;
    element.appendChild(main);

    const deleteButton = document.createElement('button');
    deleteButton.type = 'button';
    deleteButton.className = 'quick-card-delete';
    deleteButton.setAttribute('aria-label', 'Eliminar tarjeta');
    deleteButton.textContent = '✖';
    deleteButton.addEventListener('click', (event) => {
      event.stopPropagation();
      const parentCell = element.closest('td.day-cell[data-date], td.unconfirmed');
      const cardId = element.dataset.quickCardId;
      element.remove();
      removeQuickCardById(cardId);
      hideAllQuickCardDeleteButtons();
      scheduleCalendarHeightRecalc();
      if (parentCell) {
        captureTaskOrderForCell(parentCell);
      }
      const filterField = document.getElementById('filter-input');
      if (filterField && filterField.value) {
        filterField.dispatchEvent(new Event('input'));
      }
    });
    element.appendChild(deleteButton);

    element.addEventListener('click', (event) => {
      if (event.target.closest('.quick-card-delete')) {
        return;
      }
      event.stopPropagation();
      hideAllQuickCardDeleteButtons(element);
      element.classList.add('quick-card-show-delete');
    });

    element.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        hideAllQuickCardDeleteButtons(element);
        element.classList.add('quick-card-show-delete');
      }
    });

    element.tabIndex = 0;

    return element;
  }

  function attachQuickCardToCalendar(card, targetCell = null, captureOrder = true) {
    let cell = targetCell;
    if (!cell) {
      if (card.date === UNCONFIRMED_ORDER_KEY) {
        cell = document.querySelector('.pedidos-calendar td.unconfirmed');
      } else if (card.date) {
        cell = document.querySelector(`.pedidos-calendar td.day-cell[data-date="${card.date}"]`);
      }
    }
    if (!cell) {
      return null;
    }
    const element = createQuickCardElement(card);
    cell.appendChild(element);
    initTaskDrag(element);
    if (captureOrder) {
      captureTaskOrderForCell(cell);
    }
    return element;
  }

  function refreshQuickCardsFromStore() {
    document.querySelectorAll('.task.quick-card[data-quick-card-id]').forEach(el => el.remove());
    quickCardStore.forEach(card => {
      attachQuickCardToCalendar(card, null, false);
    });
    const validIds = new Set(quickCardStore.map(card => card.id));
    pruneTaskOrder(validIds);
    applyStoredOrderToCalendar();
    document.querySelectorAll('.pedidos-calendar .task').forEach(initTaskDrag);
    scheduleCalendarHeightRecalc();
    const filterField = document.getElementById('filter-input');
    if (filterField && filterField.value) {
      filterField.dispatchEvent(new Event('input'));
    }
  }

  function recalcCalendarHeights() {
    const rows = document.querySelectorAll('.pedidos-calendar tbody tr');
    if (!rows.length) return;
    rows.forEach(row => {
      const rowCells = row.querySelectorAll('td.day-cell, td.week-label');
      rowCells.forEach(cell => {
        cell.style.height = '';
      });
    });
    rows.forEach(row => {
      const rowCells = row.querySelectorAll('td.day-cell, td.week-label');
      if (!rowCells.length) {
        return;
      }
      let maxHeight = 0;
      rowCells.forEach(cell => {
        if (cell.offsetHeight > maxHeight) {
          maxHeight = cell.offsetHeight;
        }
      });
      rowCells.forEach(cell => {
        cell.style.height = `${maxHeight}px`;
      });
    });
  }

  const requestHeightFrame = window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : (cb => setTimeout(cb, 16));
  const cancelHeightFrame = window.cancelAnimationFrame
    ? window.cancelAnimationFrame.bind(window)
    : clearTimeout;
  let pendingHeightFrame = null;

  function scheduleCalendarHeightRecalc() {
    if (pendingHeightFrame !== null) {
      cancelHeightFrame(pendingHeightFrame);
      pendingHeightFrame = null;
    }
    pendingHeightFrame = requestHeightFrame(() => {
      pendingHeightFrame = null;
      recalcCalendarHeights();
    });
  }

  const calendarWrapper = document.querySelector('.pedidos-calendar-container');
  const calendarBody = document.querySelector('.pedidos-calendar tbody');
  if (calendarBody) {
    const heightObserver = new MutationObserver(() => scheduleCalendarHeightRecalc());
    heightObserver.observe(calendarBody, { childList: true, subtree: true });
  }
  if (calendarWrapper && 'ResizeObserver' in window) {
    const resizeObserver = new ResizeObserver(() => scheduleCalendarHeightRecalc());
    resizeObserver.observe(calendarWrapper);
  }
  window.addEventListener('resize', scheduleCalendarHeightRecalc, { passive: true });
  window.addEventListener('orientationchange', scheduleCalendarHeightRecalc);
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(() => scheduleCalendarHeightRecalc());
  }

  if (quickCardStorageEnabled) {
    window.addEventListener('storage', (event) => {
      if (event.key === QUICK_CARD_STORAGE_KEY) {
        quickCardStore = loadQuickCardsFromStorage();
        refreshQuickCardsFromStore();
      } else if (event.key === QUICK_CARD_ORDER_STORAGE_KEY) {
        taskOrderMap = loadTaskOrderFromStorage();
        applyStoredOrderToCalendar();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!event.target.closest('.task.quick-card')) {
      hideAllQuickCardDeleteButtons();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      hideAllQuickCardDeleteButtons();
    }
  });

  taskOrderMap = loadTaskOrderFromStorage();
  quickCardStore = loadQuickCardsFromStorage();
  refreshQuickCardsFromStore();

  if (quickCardForm) {
    quickCardForm.addEventListener('submit', (event) => {
      event.preventDefault();
      const dateValue = quickCardDate ? quickCardDate.value : '';
      const titleValue = quickCardTitle ? quickCardTitle.value.trim() : '';
      if (!dateValue || !titleValue) {
        return;
      }
      const targetCell = document.querySelector(`.pedidos-calendar td.day-cell[data-date="${dateValue}"]`);
      if (!targetCell) {
        alert('La fecha seleccionada no está visible en el calendario.');
        return;
      }
      const newCard = {
        id: generateQuickCardId(),
        date: dateValue,
        title: titleValue,
      };
      const created = attachQuickCardToCalendar(newCard, targetCell);
      if (!created) {
        alert('No se pudo crear la tarjeta en el calendario.');
        return;
      }
      quickCardStore = quickCardStore.concat([newCard]);
      persistQuickCards();
      scheduleCalendarHeightRecalc();
      const filterField = document.getElementById('filter-input');
      if (filterField && filterField.value) {
        filterField.dispatchEvent(new Event('input'));
      }
      if (quickCardForm) {
        quickCardForm.reset();
      }
      hideAllQuickCardDeleteButtons();
      created.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      if (typeof created.focus === 'function') {
        try {
          created.focus({ preventScroll: true });
        } catch (error) {
          created.focus();
        }
      }
    });
  }

  function parseSortableCell(cell) {
    if (!cell) {
      return { blank: true, value: '', type: 'text' };
    }
    const raw = cell.dataset.sort !== undefined ? cell.dataset.sort : cell.textContent.trim();
    const type = cell.dataset.sortType || 'text';
    const rawString = raw === undefined || raw === null ? '' : `${raw}`;
    const isBlank = rawString.trim() === '';
    if (type === 'number') {
      const num = Number(rawString);
      return { blank: isBlank, value: Number.isNaN(num) ? 0 : num, type };
    }
    if (type === 'date') {
      if (isBlank) {
        return { blank: true, value: 0, type };
      }
      let time = Number.NaN;
      if (/^\d{4}-\d{2}-\d{2}$/.test(rawString)) {
        time = Date.parse(rawString);
      } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(rawString)) {
        const [day, month, year] = rawString.split('/').map(Number);
        if (!Number.isNaN(day) && !Number.isNaN(month) && !Number.isNaN(year)) {
          time = Date.UTC(year, month - 1, day);
        }
      } else {
        time = Date.parse(rawString);
      }
      if (Number.isNaN(time)) {
        return { blank: true, value: 0, type };
      }
      return { blank: false, value: time, type };
    }
    return { blank: isBlank, value: rawString.toLowerCase(), type: 'text' };
  }

  function applyColumna1Sort(table, th, order) {
    if (!table || !th) return;
    const tbody = table.tBodies[0];
    if (!tbody) return;
    const headers = Array.from(table.querySelectorAll('thead th'));
    const index = headers.indexOf(th);
    if (index === -1) return;
    const rows = Array.from(tbody.querySelectorAll('tr'));
    rows.sort((a, b) => {
      const aCell = a.children[index];
      const bCell = b.children[index];
      const aVal = parseSortableCell(aCell);
      const bVal = parseSortableCell(bCell);
      if (aVal.blank && bVal.blank) return 0;
      if (aVal.blank !== bVal.blank) {
        return aVal.blank ? 1 : -1;
      }
      let comparison = 0;
      if (aVal.type === 'number' && bVal.type === 'number') {
        comparison = aVal.value - bVal.value;
      } else if (aVal.type === 'date' && bVal.type === 'date') {
        comparison = aVal.value - bVal.value;
      } else if (TABLE_COLLATOR) {
        comparison = TABLE_COLLATOR.compare(aVal.value, bVal.value);
      } else {
        comparison = aVal.value < bVal.value ? -1 : aVal.value > bVal.value ? 1 : 0;
      }
      if (comparison === 0) return 0;
      return order === 'asc' ? (comparison < 0 ? -1 : 1) : (comparison < 0 ? 1 : -1);
    });
    rows.forEach((row) => tbody.appendChild(row));
  }

  function updateColumna1HeaderState(headers, active, order) {
    headers.forEach((header) => {
      if (header === active) {
        header.dataset.sortOrder = order;
        header.classList.toggle('sorted-asc', order === 'asc');
        header.classList.toggle('sorted-desc', order === 'desc');
      } else {
        header.dataset.sortOrder = '';
        header.classList.remove('sorted-asc', 'sorted-desc');
      }
    });
  }

  function reapplyColumna1Sort(table) {
    if (!table) return;
    const active = table.querySelector('thead th.sorted-asc, thead th.sorted-desc');
    if (!active) return;
    const order = active.dataset.sortOrder || (active.classList.contains('sorted-desc') ? 'desc' : 'asc');
    applyColumna1Sort(table, active, order || 'asc');
  }

  function initColumna1Sorting(root = document) {
    root.querySelectorAll('.columna-1-table').forEach((table) => {
      const tbody = table.tBodies[0];
      if (!tbody) return;
      const headers = Array.from(table.querySelectorAll('thead th'));
      headers.forEach((th, index) => {
        if (th.dataset.sortableInit === '1') return;
        th.dataset.sortableInit = '1';
        th.classList.add('sortable');
        th.addEventListener('click', () => {
          const order = th.dataset.sortOrder === 'asc' ? 'desc' : 'asc';
          updateColumna1HeaderState(headers, th, order);
          applyColumna1Sort(table, th, order);
        });
      });
    });
  }

  function escapeHtml(value) {
    if (value === undefined || value === null) return '';
    return value
      .toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function normalizePartValue(value) {
    if (value === undefined || value === null) return '';
    const text = `${value}`.trim();
    if (!text) return '';
    const lower = text.toLowerCase();
    if (lower === 'none' || lower === 'null' || lower === 'undefined') return '';
    return text;
  }

  function formatPartSuffix(value) {
    const normalized = normalizePartValue(value);
    if (!normalized) return '';
    const num = Number(normalized);
    if (!Number.isFinite(num)) return '';
    return ` (${Math.trunc(num) + 1})`;
  }

  function parseSplitHours(value) {
    if (value === undefined || value === null || value === '') return null;
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function toSplitInputValue(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 100) / 100;
    if (Number.isInteger(rounded)) return `${rounded}`;
    return rounded.toFixed(2).replace(/0+$/, '').replace(/\.$/, '');
  }

  function formatSplitNumber(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 100) / 100;
    if (Number.isInteger(rounded)) return `${rounded}`;
    return rounded.toLocaleString('es-ES', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
  }

  function formatSplitDuration(value) {
    if (!Number.isFinite(value)) return '';
    const total = value < 0 ? 0 : value;
    const days = Math.floor(total / SPLIT_WORKDAY_HOURS);
    const remainderRaw = total - (days * SPLIT_WORKDAY_HOURS);
    const remainder = Math.round(remainderRaw * 100) / 100;
    const parts = [];
    if (days > 0) parts.push(`${days} día${days === 1 ? '' : 's'}`);
    if (remainder > 0 || parts.length === 0) {
      const hoursText = formatSplitNumber(remainder);
      const hoursLabel = remainder === 1 ? 'hora' : 'horas';
      parts.push(`${hoursText} ${hoursLabel}`);
    }
    return parts.join(' y ');
  }

  function formatSplitHint(value) {
    const duration = formatSplitDuration(value);
    return duration ? `(${duration})` : '';
  }

  function splitOrdinalLabel(index) {
    if (!Number.isInteger(index) || index < 0) return 'Horas parte';
    if (index < SPLIT_ORDINAL_WORDS.length) {
      return `Horas ${SPLIT_ORDINAL_WORDS[index]} parte`;
    }
    return `Horas parte ${index + 1}`;
  }

  function getSplitManualInputs() {
    if (!splitPartsContainer) return [];
    return Array.from(
      splitPartsContainer.querySelectorAll('input.split-part-input[data-manual="true"]')
    );
  }

  function ensureSplitRemainderInput() {
    if (!splitPartsContainer) return null;
    if (splitRemainderInput && splitRemainderInput.isConnected) {
      return splitRemainderInput;
    }
    const row = document.createElement('div');
    row.className = 'split-part-row split-remainder-row';
    const label = document.createElement('label');
    const labelSpan = document.createElement('span');
    labelSpan.className = 'split-part-label';
    label.appendChild(labelSpan);
    const input = document.createElement('input');
    input.type = 'number';
    input.readOnly = true;
    input.tabIndex = -1;
    input.className = 'split-part-input split-part-remainder';
    input.dataset.manual = 'false';
    label.appendChild(input);
    const hint = document.createElement('span');
    hint.className = 'split-hours-hint';
    label.appendChild(hint);
    row.appendChild(label);
    splitPartsContainer.appendChild(row);
    input._hintElement = hint;
    input._labelElement = labelSpan;
    splitRemainderInput = input;
    return splitRemainderInput;
  }

  function refreshSplitPartLabels() {
    const manuals = getSplitManualInputs();
    manuals.forEach((input, idx) => {
      if (input && input._labelElement) {
        input._labelElement.textContent = `${splitOrdinalLabel(idx)}:`;
      }
    });
    if (splitRemainderInput && splitRemainderInput._labelElement) {
      splitRemainderInput._labelElement.textContent = `${splitOrdinalLabel(manuals.length)}:`;
    }
  }

  function createSplitPartRow(initialValue, beforeElement) {
    if (!splitPartsContainer) return null;
    const row = document.createElement('div');
    row.className = 'split-part-row';
    const label = document.createElement('label');
    const labelSpan = document.createElement('span');
    labelSpan.className = 'split-part-label';
    label.appendChild(labelSpan);
    const input = document.createElement('input');
    input.type = 'number';
    input.min = '1';
    input.step = '1';
    input.required = true;
    input.className = 'split-part-input';
    input.dataset.manual = 'true';
    if (initialValue !== null && Number.isFinite(initialValue) && initialValue > 0) {
      input.value = toSplitInputValue(initialValue);
    }
    input.addEventListener('input', () => {
      input.classList.remove('split-input-error');
      updateSplitModalDisplay();
    });
    label.appendChild(input);
    const hint = document.createElement('span');
    hint.className = 'split-hours-hint';
    label.appendChild(hint);
    row.appendChild(label);
    input._hintElement = hint;
    input._labelElement = labelSpan;
    if (beforeElement) {
      splitPartsContainer.insertBefore(row, beforeElement);
    } else {
      splitPartsContainer.appendChild(row);
    }
    return input;
  }

  function resetSplitParts(existingParts) {
    if (!splitPartsContainer) return;
    splitPartsContainer.innerHTML = '';
    splitRemainderInput = null;
    const normalized = Array.isArray(existingParts)
      ? existingParts
          .map(value => parseSplitHours(value))
          .filter(value => Number.isFinite(value) && value > 0)
      : [];
    let manualValues = [];
    let remainderValue = null;
    if (normalized.length >= 2) {
      manualValues = normalized.slice(0, normalized.length - 1);
      remainderValue = normalized[normalized.length - 1];
    } else if (normalized.length === 1) {
      manualValues = [normalized[0]];
    }
    if (!manualValues.length) {
      manualValues = [null];
    }
    manualValues.forEach(value => {
      createSplitPartRow(value, null);
    });
    const remainder = ensureSplitRemainderInput();
    if (remainder) {
      if (remainderValue !== null) {
        remainder.value = toSplitInputValue(remainderValue);
      } else {
        remainder.value = '';
      }
    }
    refreshSplitPartLabels();
    updateSplitModalDisplay();
  }

  function updateSplitModalDisplay() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    if (splitTotalDisplay) {
      if (total === null) {
        splitTotalDisplay.textContent = '';
      } else {
        const baseNumber = formatSplitNumber(total);
        const hoursLabel = total === 1 ? 'hora' : 'horas';
        const duration = formatSplitDuration(total);
        splitTotalDisplay.textContent = `Total fase: ${baseNumber} ${hoursLabel}${duration ? ` (${duration})` : ''}`;
      }
    }
    const manuals = getSplitManualInputs();
    let manualSum = 0;
    manuals.forEach(input => {
      const value = parseSplitHours(input.value);
      if (Number.isFinite(value)) {
        manualSum += value;
      }
      if (input._hintElement) {
        input._hintElement.textContent = Number.isFinite(value) ? formatSplitHint(value) : '';
      }
      if (total !== null && Number.isFinite(total)) {
        input.setAttribute('max', total);
      } else {
        input.removeAttribute('max');
      }
    });
    if (splitRemainderInput) {
      let remainderValue = null;
      if (total !== null && Number.isFinite(total)) {
        remainderValue = total - manualSum;
      }
      if (Number.isFinite(remainderValue)) {
        const cleanValue = Math.max(remainderValue, 0);
        splitRemainderInput.value = toSplitInputValue(cleanValue);
        splitRemainderInput.classList.toggle('split-input-error', remainderValue <= 0);
        if (splitRemainderInput._hintElement) {
          splitRemainderInput._hintElement.textContent = formatSplitHint(cleanValue);
        }
      } else {
        splitRemainderInput.value = '';
        splitRemainderInput.classList.remove('split-input-error');
        if (splitRemainderInput._hintElement) {
          splitRemainderInput._hintElement.textContent = '';
        }
      }
    }
    refreshSplitPartLabels();
  }

  function prepareSplitModal(button) {
    if (!splitModal) return;
    const totalAttr = button ? parseSplitHours(button.dataset.totalHours) : null;
    const fallbackAttr = button ? parseSplitHours(button.dataset.hours) : null;
    let total = totalAttr !== null ? totalAttr : fallbackAttr;
    let existingParts = [];
    if (button) {
      const pid = button.dataset.pid;
      const phase = button.dataset.phase;
      if (pid && phase && PROJECT_DATA[pid] && PROJECT_DATA[pid].phases) {
        const phaseEntry = PROJECT_DATA[pid].phases[phase];
        if (Array.isArray(phaseEntry)) {
          existingParts = phaseEntry;
          const computedTotal = phaseEntry
            .map(value => parseSplitHours(value))
            .filter(value => Number.isFinite(value) && value > 0)
            .reduce((acc, value) => acc + value, 0);
          if (Number.isFinite(computedTotal) && computedTotal > 0) {
            total = computedTotal;
          }
        }
      }
    }
    if (total !== null && Number.isFinite(total)) {
      splitModal.dataset.totalHours = total;
    } else {
      delete splitModal.dataset.totalHours;
    }
    resetSplitParts(existingParts);
    if (fallbackAttr && Number.isFinite(fallbackAttr)) {
      const manuals = getSplitManualInputs();
      if (manuals.length) {
        const first = manuals[0];
        const currentValue = parseSplitHours(first.value);
        if (!(Number.isFinite(currentValue) && Math.abs(currentValue - fallbackAttr) < 1e-6)) {
          first.value = toSplitInputValue(fallbackAttr);
        }
      }
    }
    updateSplitModalDisplay();
    const manuals = getSplitManualInputs();
    if (manuals.length) {
      manuals[0].focus();
    }
  }

  function pickClientDate(info) {
    if (!info) return '';
    const directCandidates = [
      info.client_date,
      info.client_due_date,
      info.customer_date,
    ];
    for (const value of directCandidates) {
      if (value === undefined || value === null) continue;
      const text = `${value}`.trim();
      if (text && text !== '0') return text;
    }
    const fields = info.kanban_display_fields || {};
    const labels = ['Fecha Cliente', 'Fecha cliente'];
    for (const label of labels) {
      const raw = fields[label];
      if (raw === undefined || raw === null) continue;
      const text = `${raw}`.trim();
      if (text) return text;
    }
    return '';
  }

  function updateSplitModalDisplay() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    if (splitTotalDisplay) {
      if (total === null) {
        splitTotalDisplay.textContent = '';
      } else {
        const baseNumber = formatSplitNumber(total);
        const hoursLabel = total === 1 ? 'hora' : 'horas';
        const duration = formatSplitDuration(total);
        splitTotalDisplay.textContent = `Total fase: ${baseNumber} ${hoursLabel}${duration ? ` (${duration})` : ''}`;
      }
    }
    if (splitPart1Hint) {
      const value = splitPart1 ? parseSplitHours(splitPart1.value) : null;
      splitPart1Hint.textContent = value === null ? '' : formatSplitHint(value);
    }
    if (splitPart2Hint) {
      const value = splitPart2 ? parseSplitHours(splitPart2.value) : null;
      splitPart2Hint.textContent = value === null ? '' : formatSplitHint(value);
    }
  }

  function handleSplitPart1Input() {
    if (!splitModal) return;
    const total = parseSplitHours(splitModal.dataset.totalHours);
    const value = splitPart1 ? parseSplitHours(splitPart1.value) : null;
    if (splitPart2) {
      if (total === null || value === null) {
        splitPart2.value = '';
      } else {
        let remainder = total - value;
        if (remainder < 0) remainder = 0;
        splitPart2.value = toSplitInputValue(remainder);
      }
    }
    updateSplitModalDisplay();
  }

  function handleSplitPart2Input() {
    updateSplitModalDisplay();
  }

  function prepareSplitModal(button) {
    if (!splitModal) return;
    const totalAttr = button ? parseSplitHours(button.dataset.totalHours) : null;
    const fallbackAttr = button ? parseSplitHours(button.dataset.hours) : null;
    const total = totalAttr !== null ? totalAttr : fallbackAttr;
    if (total !== null) {
      splitModal.dataset.totalHours = total;
    } else {
      delete splitModal.dataset.totalHours;
    }
    if (splitPart1) {
      splitPart1.value = '';
      if (total !== null) splitPart1.setAttribute('max', total);
      else splitPart1.removeAttribute('max');
    }
    if (splitPart2) {
      splitPart2.value = '';
      if (total !== null) splitPart2.setAttribute('max', total);
      else splitPart2.removeAttribute('max');
    }
    updateSplitModalDisplay();
  }

  function norm(value) {
    return (value || '').toString().trim().toLowerCase();
  }

  function resolveRowPid(row) {
    if (!row) return null;
    let pid = row.dataset.pid;
    if (pid && PROJECT_DATA[pid]) {
      const cell = row.querySelector('.observations-cell');
      if (cell) syncObservationsCell(cell, pid);
      return pid;
    }

    const code = norm(row.dataset.code);
    const project = norm(row.dataset.project);
    const title = norm(row.dataset.title);
    const display = norm(row.dataset.display);
    const client = norm(row.dataset.client);

    for (const [candidatePid, info] of Object.entries(PROJECT_DATA)) {
      if (!info) continue;
      const name = norm(info.name);
      if (!name) continue;
      const [nameProject, ...rest] = name.split(' - ');
      const nameClient = norm(rest.join(' - '));
      const projectMatch = norm(nameProject);
      const codeMatch = norm(info.custom_card_id);

      if (code && codeMatch && code === codeMatch) {
        pid = candidatePid;
      } else if (code && name.includes(code)) {
        pid = candidatePid;
      } else if (project && projectMatch === project) {
        pid = candidatePid;
      } else if (title && (name === title || name.startsWith(title) || title.startsWith(name))) {
        pid = candidatePid;
      } else if (display && name === display) {
        pid = candidatePid;
      } else if (project && name.includes(project) && (!client || !nameClient || client === nameClient)) {
        pid = candidatePid;
      }

      if (pid) {
        row.dataset.pid = pid;
        const cell = row.querySelector('.observations-cell');
        if (cell) syncObservationsCell(cell, pid);
        return pid;
      }
    }
    return null;
  }

  function clearStartDayHighlight() {
    if (startDayHighlightCell && startDayHighlightCell.isConnected) {
      startDayHighlightCell.classList.remove(START_DAY_HIGHLIGHT_CLASS);
    }
    startDayHighlightCell = null;
  }

  function applyStartDayHighlight(dateValue) {
    const iso = normalizeDateToIso(dateValue);
    clearStartDayHighlight();
    if (!iso) return;
    const cell = document.querySelector(`.pedidos-calendar td[data-date='${iso}']`);
    if (cell) {
      cell.classList.add(START_DAY_HIGHLIGHT_CLASS);
      startDayHighlightCell = cell;
    }
  }

  function resolvePlannedStartByPid(pid) {
    if (!pid) return '';
    const candidates = new Set();
    const startEntry = START_DATA && START_DATA[pid];
    if (startEntry && typeof startEntry === 'object') {
      Object.values(startEntry).forEach(value => {
        const iso = normalizeDateToIso(value);
        if (iso) candidates.add(iso);
      });
    }
    const info = PROJECT_DATA && PROJECT_DATA[pid];
    if (info) {
      ['plan_start', 'montar_start', 'start', 'start_date'].forEach(key => {
        const iso = normalizeDateToIso(info && info[key]);
        if (iso) candidates.add(iso);
      });
      if (info.segment_starts && typeof info.segment_starts === 'object') {
        Object.values(info.segment_starts).forEach(value => {
          const iso = normalizeDateToIso(value);
          if (iso) candidates.add(iso);
        });
      }
    }
    if (!candidates.size) return '';
    return Array.from(candidates).sort()[0];
  }

  function resolvePlannedStartFromRow(row) {
    if (!row) return '';
    const direct = normalizeDateToIso(row.dataset.plan);
    if (direct) return direct;
    const pid = resolveRowPid(row);
    if (!pid) return '';
    return resolvePlannedStartByPid(pid);
  }

  function highlightProjectStartByPid(pid) {
    applyStartDayHighlight(resolvePlannedStartByPid(pid));
  }

  function highlightProjectStartByRow(row) {
    applyStartDayHighlight(resolvePlannedStartFromRow(row));
  }

  function afterMove(data, originalDate) {
    localStorage.setItem(LAST_KEY, JSON.stringify({pid: data.pid, phase: data.phase, part: data.part, date: data.date}));
    if (data.date !== originalDate) localStorage.setItem(SCROLL_KEY2, data.date);
    location.reload();
  }

  function makeDraggable(el) {
    if (!el) return;
    let startX, startY, startLeft, startTop;
    const onMouseMove = (ev) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      el.style.left = startLeft + dx + 'px';
      el.style.top = startTop + dy + 'px';
    };
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    el.addEventListener('mousedown', (ev) => {
      if (ev.target.closest('input, textarea, select, button')) return;
      startX = ev.clientX;
      startY = ev.clientY;
      const rect = el.getBoundingClientRect();
      startLeft = rect.left + window.scrollX;
      startTop = rect.top + window.scrollY;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }

  document.addEventListener('click', () => {
    if (popup) popup.style.display = 'none';
  });
  if (popup) {
    popup.addEventListener('click', (e) => e.stopPropagation());
  }

  document.querySelectorAll('.modal-content, .conflict-content, .info-popup').forEach(makeDraggable);

  if (splitCancel) {
    splitCancel.addEventListener('click', () => { if (splitModal) splitModal.style.display = 'none'; });
  }
  if (splitForm && !splitForm.dataset.enhanced) {
    splitForm.addEventListener('submit', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (!splitModal) return;
      const manuals = getSplitManualInputs();
      if (!manuals.length) {
        alert('Debes indicar al menos una parte.');
        return;
      }
      const parts = [];
      let invalid = false;
      manuals.forEach(input => {
        const value = parseSplitHours(input.value);
        if (!Number.isInteger(value) || value <= 0) {
          input.classList.add('split-input-error');
          invalid = true;
          return;
        }
        parts.push(value);
      });
      const remainderValue = splitRemainderInput ? parseSplitHours(splitRemainderInput.value) : null;
      const total = parseSplitHours(splitModal.dataset.totalHours);
      let remainderInt = null;
      if (!Number.isInteger(remainderValue) || remainderValue === null || remainderValue <= 0) {
        invalid = true;
      } else {
        remainderInt = remainderValue;
        parts.push(remainderInt);
      }
      const sumParts = parts.reduce((acc, value) => acc + value, 0);
      if (total !== null && Number.isFinite(total) && sumParts !== total) {
        invalid = true;
      }
      if (invalid) {
        alert('Revisa las horas de cada parte. Deben ser enteros positivos y sumar el total de la fase.');
        updateSplitModalDisplay();
        return;
      }
      fetch(SPLIT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({
          pid: splitModal.dataset.pid,
          phase: splitModal.dataset.phase,
          date: splitModal.dataset.date,
          parts,
        })
      }).then(resp => { if (resp.ok) location.reload(); else resp.json().then(d => alert(d.error || 'Error')); });
    });
    splitForm.dataset.enhanced = 'true';
  }

  if (splitAddPartButton && !splitAddPartButton.dataset.bound) {
    splitAddPartButton.addEventListener('click', ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const remainderRow = splitRemainderInput ? splitRemainderInput.closest('.split-part-row') : null;
      const input = createSplitPartRow(null, remainderRow);
      ensureSplitRemainderInput();
      updateSplitModalDisplay();
      if (input) input.focus();
    });
    splitAddPartButton.dataset.bound = 'true';
  }

  function buildPhaseSection(info, context) {
    const phaseLines = [];
    PHASES.forEach(ph => {
      if (ph === 'dibujo' || ph === 'pedidos') return;
      const raw = info.phases ? info.phases[ph] : null;
      let total = 0;
      if (Array.isArray(raw)) total = raw.map(v => parseInt(v)).reduce((a,b) => a + b, 0);
      else total = parseInt(raw) || 0;
      if (total > 0) {
        const assigned = (info.assigned && info.assigned[ph]) || 'Sin planificar';
        const classes = ['phase-entry'];
        classes.push(assigned === 'Sin planificar' ? 'unplanned' : 'planned');
        const isActivePhase = ph === context.phase;
        const partSuffix = isActivePhase ? formatPartSuffix(context.part) : '';
        let line = `<div class="${classes.join(' ')}">${ph}${partSuffix}: ${total}h`;
        if (isActivePhase) {
          const partValue = normalizePartValue(context.part);
          const partAttr = partValue ? ` data-part="${partValue}"` : '';
          line += ` <form id="phase-hours-form" style="display:inline"><input type="number" id="phase-hours-input" value="${total}" min="1" required><button type="submit" data-pid="${context.pid}" data-phase="${ph}"${partAttr}>Cambiar horas</button></form>`;
        }
        line += `</div>`;
        phaseLines.push(line);
      }
    });
    let section = '';
    if (phaseLines.length) section += phaseLines.join('');
    if (context.phase === 'pedidos') {
      const acopio = info.phases ? info.phases['pedidos'] : null;
      if (acopio && acopio !== '0') section += `<div>Plazo acopio: ${acopio}</div>`;
    }
    return section;
  }

  function openPhasePopup(context, anchorRect) {
    if (!popup) return;
    const info = PROJECT_DATA[context.pid];
    if (!info) return;
    const headerParts = [info.name];
    if (info.blocked) headerParts[0] += ' <span class="blocked-sign">\u{1F6AB}</span>';
    headerParts.push(info.client || '');
    if (context.phase) headerParts.push(`${context.phase}${formatPartSuffix(context.part)}`);
    let html = `<div class="popup-section popup-header"><strong>${headerParts.filter(Boolean).join(' - ')}</strong></div>`;
    const metaLines = [];
    const clientDate = pickClientDate(info);
    if (clientDate) metaLines.push(`<div>Fecha cliente: ${clientDate}</div>`);
    const safeProjectAttr = escapeHtml(context.project || info.name || '');
    const safePidAttr = escapeHtml(context.pid || '');
    metaLines.push(`<div><button type="button" class="view-calendar-btn" data-project="${safeProjectAttr}" data-pid="${safePidAttr}">Ver calendario</button></div>`);
    if (info.due_date && info.due_date !== '0') metaLines.push(`<div>Límite: ${info.due_date}</div>`);
    if (info.material_confirmed_date && info.material_confirmed_date !== '0') metaLines.push(`<div>Material confirmado: ${info.material_confirmed_date}</div>`);
    if (metaLines.length) html += `<div class="popup-section">${metaLines.join('')}</div>`;
    const kanbanFields = info.kanban_display_fields || {};
    const kanbanEntries = Object.entries(kanbanFields).filter(([, value]) => value !== null && value !== undefined && `${value}`.trim() !== '');
    if (kanbanEntries.length) {
      let kanbanHtml = '<div class="popup-section kanban-extra-fields">';
      kanbanEntries.forEach(([label, value]) => {
        kanbanHtml += `<div>${label}: ${value}</div>`;
      });
      kanbanHtml += '</div>';
      html += kanbanHtml;
    }
    const phaseSection = buildPhaseSection(info, context);
    if (phaseSection) html += `<div class="popup-section">${phaseSection}</div>`;
    const actionLines = [];
    if (context.phase) {
      const startVal = (START_DATA[context.pid] && START_DATA[context.pid][context.phase]) || '';
      actionLines.push(`<div>Inicio de la fase: <form id="start-form" style="display:inline"><input type="date" id="start-input" value="${startVal}" required><button type="submit" id="start-btn" data-pid="${context.pid}" data-phase="${context.phase}">Cambiar</button></form></div>`);
      actionLines.push(`<div><button id="freeze-btn" data-pid="${context.pid}" data-phase="${context.phase}" style="color:red;font-weight:bold">${(info.frozen_phases && info.frozen_phases.includes(context.phase)) ? 'Descongelar' : 'Congelar'}</button></div>`);
      const phaseHoursEntry = info.phases ? info.phases[context.phase] : null;
      let totalPhaseHours = null;
      if (Array.isArray(phaseHoursEntry)) {
        totalPhaseHours = phaseHoursEntry
          .map(v => Number(v) || 0)
          .reduce((acc, val) => acc + val, 0);
      } else if (phaseHoursEntry !== undefined && phaseHoursEntry !== null && `${phaseHoursEntry}`.trim() !== '') {
        const parsedPhase = Number(phaseHoursEntry);
        if (Number.isFinite(parsedPhase)) totalPhaseHours = parsedPhase;
      }
      const totalHoursAttr = totalPhaseHours !== null ? ` data-total-hours="${totalPhaseHours}"` : '';
      const partHoursAttr = totalPhaseHours !== null ? ` data-hours="${totalPhaseHours}"` : '';
